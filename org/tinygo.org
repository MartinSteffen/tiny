* Go

  http://noypi-linux.blogspot.no/2014/07/golang-parser-generator-ebnfyacclex.html

  https://github.com/blynn/nex


  https://github.com/cznic/golex

  
** Misc (later more structure)



*** DONE read about SSA <2015-08-01 Sat 08:34>
    CLOSED: [2015-08-07 Fri 12:43]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-08-07 Fri 12:43]
    :END:
    I do it in notes/sa.tex
*** TODO where do they transform the program into SSA? <2015-08-01 Sat 09:20>
    :PROPERTIES:
    :ID:       873919ce-1cd9-4578-86fe-d32ca30589d0
    :END:
*** TODO do they represent the Phi functions` <2015-08-01 Sat 09:20>
    :PROPERTIES:
    :ID:       d93ad74b-1919-4807-ae3c-73d5920ddefa
    :END:
*** DONE remove the prints from the walker  <2015-07-30 Thu 09:44>
    CLOSED: [2015-07-30 Thu 09:46]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-30 Thu 09:46]
    :END:
*** DONE adapt the client-side visitor <2015-07-30 Thu 08:49>
    CLOSED: [2015-07-30 Thu 09:42]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-30 Thu 09:42]
    :END:
*** DONE add the multiplication <2015-07-30 Thu 07:40>
    CLOSED: [2015-07-30 Thu 08:49]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-30 Thu 08:49]
    :END:

**** DONE repair/add cases to ~WalkTerm~ <2015-07-30 Thu 07:57>
     CLOSED: [2015-07-30 Thu 08:49]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-30 Thu 08:49]
     :END:

*** DONE add ~WalkMulOp~ <2015-07-30 Thu 08:09>
    CLOSED: [2015-07-30 Thu 08:17]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-30 Thu 08:17]
    :END:
*** DONE add walk for numbers <2015-07-30 Thu 08:26>
    CLOSED: [2015-07-30 Thu 08:35]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-30 Thu 08:35]
    :END:
*** DONE walk for compare operations <2015-07-30 Thu 08:20>
    CLOSED: [2015-07-30 Thu 08:42]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-30 Thu 08:42]
    :END:
*** DONE add ~WalkFactor~ <2015-07-30 Thu 07:59>
    CLOSED: [2015-07-30 Thu 08:37]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-30 Thu 08:37]
    :END:
*** DONE Is there no multiplication in the original grammar? Is there such a grammer? <2015-07-29 Wed 20:40>
    CLOSED: [2015-07-30 Thu 07:40]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-30 Thu 07:40]
    :END:
    Wes, there is. We should also add it to the ml-file.

*** DONE what's the status if visitor2.go <2015-07-29 Wed 07:06>
    CLOSED: [2015-07-29 Wed 07:12]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-29 Wed 07:12]
    :END:
    is it up-to date?
    
    No, the question is why?


    => 2 different files, one not under git

*** DONE what can one do with the visitor thing, the channel? <2015-07-28 Tue 12:05>
    CLOSED: [2015-07-29 Wed 10:44]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-29 Wed 10:44]
    :END:

Currently, my code gives a deadlock anyway.    
**** DONE check perhaps the printer test code <2015-07-28 Tue 12:05>
     CLOSED: [2015-07-28 Tue 14:56]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-28 Tue 14:56]
     :END:

#+begin_example
func idents(f *ast.File) <-chan *ast.Ident {
	v := make(visitor)
	go func() {
		ast.Walk(v, f)
		close(v)
	}()
	return v
}

// identCount returns the number of identifiers found in f.
func identCount(f *ast.File) int {
	n := 0
	for range idents(f) {
		n++
	}
	return n
}

#+end_example

The first function creates the visitor, which is a channel, actually, the
way it's declared in this function for the return type, it's a
read-channel. Actually, the second function makes a weird use of it, it
does not receive and values, it just counts the number. The
~close~-function is a built-in function for channels. The role of the
~go~-statement here is not so clear.  The set-up here is different from the
one in the go-compiler. 
**** DONE test if one should close the channel? <2015-07-29 Wed 07:19>
     CLOSED: [2015-07-29 Wed 10:44]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-29 Wed 10:44]
     :END:
     

**** DONE what's the type of the ~idents~ function here? <2015-07-28 Tue 12:14>
     CLOSED: [2015-07-28 Tue 14:45]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-28 Tue 14:45]
     :END:

The ``type' seems to be ~(f *ast.File) <-chan *ast.Ident~. That's the
/signature/. I would guess that ~*ast.File~ is the /parameters/ and the
rest ~<-chan *ast.Ident~ is the /result/. I guess, it's a ~Type~, not
~Parameters~. From that, I guess it's a ~ChannelType~. Indeed, there are
variations, distinguishing input and output channels. In this case, with
the arrow attached to the /left/ of ~chan~, it's a channel to /receive/
data, in this case, identifiers.

*** DONE why does the go-src channel visitor not deadlock <2015-07-29 Wed 07:44>
    CLOSED: [2015-07-29 Wed 10:44]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-29 Wed 10:44]
    :END:

    The Visit function does not contain parallelism. It's in the functions
    afterwards. The function ~idents~ seems to spawn one new thread, which
    does the walk (using the visitor channel). It's one thread, which
    /sends/ on the channel. Since it's still a zero-element (synchronous)
    channel, the walk through the ast cannot just finish, it will block
    until another process reads from the channel, so there is some
    /synchronization/ going on. Note that the walk is asynchronous, i.e.,
    the ~idents~ function spawns the walker and, without waiting for its
    finishing, returns the channel/visitor as result. 

    Why the ~range~ works, is unclear, and also 

**** DONE how can it not deadlock, considering that no receiving is done <2015-07-29 Wed 08:04>
     CLOSED: [2015-07-29 Wed 10:41]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-29 Wed 10:41]
     :END:
     It's strange, it seems that the ~idents~-function sends to the
     channel, but no one actually reads from it. Therefore, I'd expect a
     deadlock.  In /my/ current code, if I use the ~range~-loop, there's a
     deadlock, but that is because I don't have parallelism. What is less
     clear is: if I /remove/ the ~range~-loop, then all is fine. That's
     probably, because if the main thread terminates, all is torn down, and
     therefore there is no deadlock.

     

***** DONE check if the visitor does the right thing on the example <2015-07-29 Wed 10:19>
      CLOSED: [2015-07-29 Wed 10:40]
      :LOGBOOK:
      - State "DONE"       from "TODO"       [2015-07-29 Wed 10:40]
      :END:
      The expression loops as follows

           ~IF(SIMPLEEXPR(TERM(FACTOR(ID("s"))), READo("x"), READ("x"))~

      Currently, only ~VisitExpr~ and ~VisitStmt~ has an action attached
      (in the form of sending an integer (and printing). The actuos are 
      Stmt -> Expr -> Expr -> Expr, which makes sense.

      
***** FIXED why does the visitor (the walk) never print anything <2015-07-29 Wed 09:31>
      CLOSED: [2015-07-29 Wed 10:18]
      :LOGBOOK:
      - CLOSING NOTE [2015-07-29 Wed 10:18] \\
	The walk functions just passed on the visitor, but it was never acted upon,
	by calling it.
      :END:
      Actually, the ~WalkStmt~ etc are executed, because the currently
      added print-statements are executed. What seems not executed is the
      ``client-side'' code, i.e., the code in the file ~visitor2.go~.

****** DONE add appropriate calls to ~Visit~-functions <2015-07-29 Wed 10:04>
       CLOSED: [2015-07-29 Wed 10:06]
       :LOGBOOK:
       - State "DONE"       from "TODO"       [2015-07-29 Wed 10:06]
       :END:
       I added it to the walkers for statement and expressions 
       
****** DONE do I ever /call/ any visit function? <2015-07-29 Wed 09:52>
       CLOSED: [2015-07-29 Wed 09:57]
       :LOGBOOK:
       - State "DONE"       from "TODO"       [2015-07-29 Wed 09:57]
       :END:
       The entry point in the current design is ~WalkStmt~.  However, it
       the whole file ~walk.go~, no ~Visit~-function is ever
       called. Basically it means, that the walk functions currently just
       perform a walk-through, without ever executing the action connected
       to the visitor.


****** DONE does the go-src actually make use of functions like ~Visit~ <2015-07-29 Wed 09:36>
       CLOSED: [2015-07-29 Wed 09:41]
       :LOGBOOK:
       - State "DONE"       from "TODO"       [2015-07-29 Wed 09:41]
       :END:
       Yes, they do, and it's the same as here, sending stuff over the channel
****** DONE where and how in the go-src is the actual ~Visit~-function called? <2015-07-29 Wed 09:47>
       CLOSED: [2015-07-29 Wed 09:50]
       :LOGBOOK:
       - State "DONE"       from "TODO"       [2015-07-29 Wed 09:50]
       :END:
       At the beginning of the ~Walk~-function! Since the walk-function is recursive,
       it will be called repeatedly
***** CANCELLED it's there are difference between go ... and go func () ...? <2015-07-29 Wed 09:03>
      CLOSED: [2015-07-29 Wed 10:41]
      :LOGBOOK:
      - CLOSING NOTE [2015-07-29 Wed 10:41]
      :END:
      Perhaps just test it 
***** DONE What does ~range~ on a channel do <2015-07-29 Wed 08:04>

      CLOSED: [2015-07-29 Wed 08:48]
      :LOGBOOK:
      - State "DONE"       from "TODO"       [2015-07-29 Wed 08:48]
      :END:

      Indeed, the range reads from the channel:
      
      ``For channels, the iteration values produced are the successive
      values sent on the channel until the channel is closed.''

*** DONE deadlock: why? <2015-07-28 Tue 15:08>
    CLOSED: [2015-07-29 Wed 07:43]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-29 Wed 07:43]
    :END:


    Why does the following code give a deadlock

#+begin_example
func main () {
	v := make (visitor)   // creating a visitor (which is a chan)
	absynt.WalkStmt (v,s)
	n := 0 
	for range v {
		n ++
	}
	fmt.Println(v)
}
#+end_example

The error message (after printing the stuff) is ~fatal error: all
goroutines are asleep - deadlock!~. If one removes the for-loop, there's no
deadlock.e It's the ~for range v~-loop, the body does not play a role. If
one puts a print-command inside the loop, the prints are not executed
before the deadlock happens. 

If one closes the channel, the deadlock goes away. But it's also not what
we want. The closed channel is ``empty'' and has a range of 0, so the loop
is not executed. Therefore we see also the deadlock: The walk function
tries to write two times or more, and then that deadlocks.



*** DONE adapt the test directory accordingly <2015-07-28 Tue 10:55>
    CLOSED: [2015-07-28 Tue 15:00]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-28 Tue 15:00]
    :END:

**** DONE glue on the various VisitXXX methods to visitor <2015-07-28 Tue 11:31>
     CLOSED: [2015-07-28 Tue 11:34]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-28 Tue 11:34]
     :END:
     to make it to a Visitor 
*** DONE make an ``overloaded'' visitor, is that possible  <2015-07-28 Tue 09:43>
    CLOSED: [2015-07-28 Tue 11:35]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-28 Tue 11:35]
    :END:
    
    The problem currently is as follows: currently (being slightly
    simplified) we concentrate on statements and expressions. Now, we have
    2 visitors, statement visitors and expresion visitors. We start at a
    statement, and call the function WalkStmt. the wargument is a statement
    vistitor.

    Now, as a consequence the following is incorrect:
   
     func WalkStmt (sv StmtVisitor, s Stmt) {
	switch ts := s.(type) { // type assertion
	case *IF:
		fmt.Println ("IF (")
		WalkExpr (sv, ts.E)    // this is not how it works
		WalkStmt (sv, ts.SL1)
     ...

     The statement visitor cannot be used to visit the expression. We can
     of course hand over all the visitors (perhaps arranged in an array or
     record). That's however, not nice. Currently, Walk is a function, so one question
     is: can one overload functions? It's unclear if one can overload methods (but I guess
     that's more probable).

     Now it works

*** DONE can one overload functions (not methods), say Walk <2015-07-28 Tue 09:51>
    CLOSED: [2015-07-28 Tue 09:54]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-28 Tue 09:54]
    :END:

No, the two definitions cannot be in the same file (probably same package)

#+begin_example
func Walk (v Visitor, p Program) {
}


func Walk (w int, s Stmt) {
}

#+end_example

*** DONE add multiple visitors (if possible) <2015-07-28 Tue 10:37>
    CLOSED: [2015-07-28 Tue 10:50]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-28 Tue 10:50]
    :END:
    One of the problems I currently have: 

#+begin_example

	visitor does not implement absynt.Visitor (wrong type for Visit method)
		have Visit(absynt.Stmt) absynt.Visitor
		want Visit(absynt.Node) absynt.Visitor
#+end_example
     

   So, basically I will not add multiple visitors, but one visitor with many visit-methods

**** DONE does it compile if one overloads the Visit-method in one interface <2015-07-28 Tue 10:39>
     CLOSED: [2015-07-28 Tue 10:41]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-28 Tue 10:41]
     :END:

     No, the following does not compile


#+begin_example
type Visitor interface {
	Visit(Node) (Visitor)
	Visit(Stmt) (Visitor)
}
#+end_example

**** DONE add multiple Visit-functions to the Visitor (to avoid overloading) <2015-07-28 Tue 10:42>
     CLOSED: [2015-07-28 Tue 10:49]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-28 Tue 10:49]
     :END:

     The design then is :

#+begin_example
type Visitor interface {
//	Visit(Node) (Visitor)
	VisitStmt(Stmt) (Visitor)
	VisitExpr(Expr) (Visitor)	
}
#+end_example     
     
   This is ``dual'' to before where I had VisitorStmt etc, but all with the 
   commonly named Visit-Method.

*** DONE fill out walk-simple-expression <2015-07-28 Tue 09:54>
    CLOSED: [2015-07-30 Thu 08:37]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-30 Thu 08:37]
    :END:
*** DONE make the print outside the walk itself <2015-07-28 Tue 09:31>
    CLOSED: [2015-07-29 Wed 10:45]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-29 Wed 10:45]
    :END:
    Currently I add some prints to the walk. It would be more
    better/more instructive, if we could add them to the visiting function somehow.
    For the time being, it's for debugging, but later we need to find
    different kind of visitors.
*** DONE can one overload the Visit method <2015-07-28 Tue 09:55>
    CLOSED: [2015-07-29 Wed 10:45]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-29 Wed 10:45]
    :END:

*** DONE why is there no ~AddOp~ or similar <2015-07-29 Wed 15:56>
    CLOSED: [2015-07-29 Wed 15:57]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-29 Wed 15:57]
    :END:
    Actually, there is, in absynt.go
*** DONE add ~VisitAddOp~ <2015-07-29 Wed 15:57>
    CLOSED: [2015-07-29 Wed 16:17]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-29 Wed 16:17]
    :END:
*** DONE replate Add_Op with AddOp, for uniformity <2015-07-29 Wed 15:58>
    CLOSED: [2015-07-29 Wed 16:11]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-29 Wed 16:11]
    :END:
*** DONE add ~VisitNumber~ <2015-07-29 Wed 15:50>
    CLOSED: [2015-07-29 Wed 16:18]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-29 Wed 16:18]
    :END:
*** DONE add ~VisitTerm~ <2015-07-29 Wed 12:42>
    CLOSED: [2015-07-29 Wed 16:20]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-29 Wed 16:20]
    :END:
**** DONE fill out VisitTerm <2015-07-29 Wed 12:53>
     CLOSED: [2015-07-29 Wed 16:20]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-29 Wed 16:20]
     :END:

*** DONE make a visitor for ~SimpleExpr~ <2015-07-29 Wed 18:59>

*** DONE make client code of ~SimpleExpr~ <2015-07-29 Wed 19:02>
    CLOSED: [2015-07-29 Wed 19:07]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-29 Wed 19:07]
    - State "DONE"       from "TODO"       [2015-07-29 Wed 19:01]
    :END:
*** DONE add visitors for Symbols <2015-07-29 Wed 19:10>
    CLOSED: [2015-07-29 Wed 19:21]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-29 Wed 19:21]
    :END:
*** DONE clean up a bit <2015-07-29 Wed 18:47>
    CLOSED: [2015-07-29 Wed 19:07]
    :LOGBOOK:
    - State "DONE"       from "UNDERWAY"   [2015-07-29 Wed 19:07]
    :END:
*** DONE do we need Node <2015-07-29 Wed 18:47>
    CLOSED: [2015-07-29 Wed 18:47]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-29 Wed 18:47]
    :END:
*** DONE add WalkAddOp <2015-07-29 Wed 17:49>
    CLOSED: [2015-07-30 Thu 08:38]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-30 Thu 08:38]
    :END:
*** FIXED Type error: ./walk.go:124:  <2015-07-29 Wed 17:04>
    CLOSED: [2015-07-29 Wed 17:49]
    :LOGBOOK:
    - CLOSING NOTE [2015-07-29 Wed 17:49] \\
      just wrong case
    :END:
    impossible type switch case: se (type SimpleExpr) cannot have dynamic type *COMPAREEXPR (missing simpleexpr_Node method)
*** DONE add case for ~ADDEXPR~ <2015-07-29 Wed 16:36>
    CLOSED: [2015-07-29 Wed 19:21]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-29 Wed 19:21]
    :END:
*** DONE add ~VisitFactor~ <2015-07-29 Wed 12:42>
    CLOSED: [2015-07-29 Wed 19:22]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-29 Wed 19:22]
    :END:
**** DONE fill out VisitFactor <2015-07-29 Wed 12:53>
     CLOSED: [2015-07-29 Wed 16:29]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-29 Wed 16:29]
     :END:
**** DONE call VisitFactor appropriately <2015-07-29 Wed 12:53>
     CLOSED: [2015-07-29 Wed 19:22]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-29 Wed 19:22]
     :END:
*** DONE re-add the functional stuff <2015-07-30 Thu 12:35>
    CLOSED: [2015-07-30 Thu 14:14]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-30 Thu 14:14]
    :END:
*** DONE make visitor2 work again <2015-07-30 Thu 12:39>
    CLOSED: [2015-07-30 Thu 14:18]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-30 Thu 14:18]
    :END:
*** DONE clean up the stuff <2015-07-30 Thu 12:24>
    CLOSED: [2015-07-30 Thu 12:35]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-30 Thu 12:35]
    :END:
*** DONE hook onto the example <2015-07-30 Thu 14:11>
    CLOSED: [2015-07-30 Thu 14:13]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-30 Thu 14:13]
    :END:
*** DONE clean up <2015-07-30 Thu 14:00>
    CLOSED: [2015-07-30 Thu 14:15]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-30 Thu 14:15]
    :END:
*** DONE make visitfunctional compile again <2015-07-30 Thu 14:00>
    CLOSED: [2015-07-30 Thu 14:08]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-30 Thu 14:08]
    :END:
*** DONE externalize the example tree in a separate file (or package) <2015-07-30 Thu 10:11>
    CLOSED: [2015-07-30 Thu 12:36]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-30 Thu 12:36]
    :END:
***** DONE make the record thing functional <2015-07-30 Thu 10:29>
      CLOSED: [2015-07-30 Thu 12:36]
      :LOGBOOK:
      - State "DONE"       from "TODO"       [2015-07-30 Thu 12:36]
      :END:
      Just to se**** TODO Can one make a direct (channelless) counting visitor? <2015-07-30 Thu 10:08>
    Let's do it in ~visitordirectcount.go~.

***** DONE make a visitable counting visitor <2015-07-30 Thu 10:16>
      CLOSED: [2015-07-30 Thu 10:48]
      :LOGBOOK:
      - State "DONE"       from "TODO"       [2015-07-30 Thu 10:48]
      :END:
***** DONE make the record thing imperative first <2015-07-30 Thu 10:29>
      CLOSED: [2015-07-30 Thu 12:35]
      :LOGBOOK:
      - State "DONE"       from "TODO"       [2015-07-30 Thu 12:35]
      :END:
***** DONE change the visitor interface to an imperative one <2015-07-30 Thu 11:42>
      CLOSED: [2015-07-30 Thu 12:36]
      :LOGBOOK:
      - State "DONE"       from "TODO"       [2015-07-30 Thu 12:36]
      :END:
***** DONE adapt the client code <2015-07-30 Thu 11:42>
      CLOSED: [2015-07-30 Thu 12:35]
      :LOGBOOK:
      - State "DONE"       from "TODO"       [2015-07-30 Thu 12:35]
      :END:
****** DONE are structs immutable <2015-07-30 Thu 11:16>
       CLOSED: [2015-07-30 Thu 11:24]
       :LOGBOOK:
       - State "DONE"       from "TODO"       [2015-07-30 Thu 11:24]
       :END:
       no, easy to change
******* DONE make the same experiment with parameter passing <2015-07-30 Thu 11:28>
	CLOSED: [2015-07-30 Thu 12:35]
	:LOGBOOK:
	- State "DONE"       from "TODO"       [2015-07-30 Thu 12:35]
	:END:

	If we do it like that, it's ok.
#+begin_example
type record struct{x int}

func inc (s  *record) {
	s.x = 7
}

func main () {
	r:= record{4}
	fmt.Println("1",r)
	r.x = 5
	fmt.Println("2",r)
	inc(&r)
	fmt.Println("2",r)
	
}

#+end_example
****** DONE why does the count does not go up <2015-07-30 Thu 10:49>
       CLOSED: [2015-07-30 Thu 12:24]
       :LOGBOOK:
       - State "DONE"       from "TODO"       [2015-07-30 Thu 12:24]
       :END:
       Currently
       v=v.VisitStmt(s)          // action 

***** DONE how to create a struct <2015-07-30 Thu 10:20>
      CLOSED: [2015-07-30 Thu 10:21]
      :LOGBOOK:
      - State "DONE"       from "TODO"       [2015-07-30 Thu 10:21]
      :END:
      Need the type name
***** DONE can one turn ~int~ into a visitor? <2015-07-30 Thu 10:13>
      CLOSED: [2015-07-30 Thu 10:15]
      :LOGBOOK:
      - State "DONE"       from "TODO"       [2015-07-30 Thu 10:15]
      :END:

      Not really, numbers cannot accept methods.

    

    

*** TODO make the record thing functional <2015-07-30 Thu 10:29>
    :PROPERTIES:
    :ID:       50dd9fa7-d794-4ba3-80bb-6bda466b5987
    :END:
      Just to se*** TODO write down a rational scheme how that worked <2015-07-29 Wed 12:34>

    Now the visitors etc work. The question is, how close it's connected 
**** TODO is it necessary to give back the ~v~ in the visitor <2015-07-30 Thu 10:01>
     :PROPERTIES:
     :ID:       4b724bfc-00ef-461e-86e0-08c9c4e80fb1
     :END:
     Actually, in my code it's not needed, it seems. Perhaps that's due to the fact that
     the channel is essentially imperative, we don't give back the value, but 
     share a channel
     
**** TODO what's the role now of ~w~? <2015-07-30 Thu 09:56>
     :PROPERTIES:
     :ID:       06132efe-b502-4ecc-bf1a-2f0310c35119
     :END:
     
**** DONE what's the ``type'' of the whole  visitor thing? <2015-07-29 Wed 12:34>
     CLOSED: [2015-08-07 Fri 12:43]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-08-07 Fri 12:43]
     :END:

**** DONE can one do something else than a channel <2015-07-29 Wed 12:34>
     CLOSED: [2015-08-01 Sat 09:21]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-08-01 Sat 09:21]
     :END:
*** DONE rename Compare_Op to CompareOp (for style) <2015-07-29 Wed 11:33>
    CLOSED: [2015-07-29 Wed 12:31]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-29 Wed 12:31]
    :END:
*** DONE add an expression case  for  ~COMPAREEXPR~ <2015-07-29 Wed 11:23>
    CLOSED: [2015-07-29 Wed 12:29]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-29 Wed 12:29]
    :END:
**** DONE add ~WalkCompareOp~ <2015-07-29 Wed 11:25>
     CLOSED: [2015-07-29 Wed 12:29]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-29 Wed 12:29]
     :END:
**** DONE add a client side Visitor for Compare_Ops <2015-07-29 Wed 12:27>
     CLOSED: [2015-07-29 Wed 12:29]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-29 Wed 12:29]
     :END:
**** DONE add a case for ~CompareOp~ for the visitors <2015-07-29 Wed 12:13>
     CLOSED: [2015-07-29 Wed 12:26]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-29 Wed 12:26]
     :END:
*** DONE add a statement case for ~ASSIGN~ <2015-07-29 Wed 11:21>
    CLOSED: [2015-07-29 Wed 11:22]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-29 Wed 11:22]
    :END:
*** DONE add a statement case for ~REPEAT~ <2015-07-29 Wed 11:16>
    CLOSED: [2015-07-29 Wed 11:20]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-29 Wed 11:20]
    :END:
*** DONE Change back the visitor for Nodes? <2015-07-28 Tue 10:00>
    CLOSED: [2015-07-29 Wed 10:45]
    :LOGBOOK:
    - State "DONE"       from "PENDING"    [2015-07-29 Wed 10:45]
    :END:
    It was "Program" before, for experimenting I made it to nodes.
*** DONE add a case for WRITE <2015-07-29 Wed 11:08>
    CLOSED: [2015-07-29 Wed 11:14]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-29 Wed 11:14]
    :END:
*** DONE add WalkIdent <2015-07-29 Wed 10:47>
    CLOSED: [2015-07-29 Wed 11:07]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-29 Wed 11:07]
    :END:
**** DONE add ~VisitIdent~ to the ~Visitor~-Interface <2015-07-29 Wed 10:57>
     CLOSED: [2015-07-29 Wed 10:58]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-29 Wed 10:58]
     :END:
*** DONE implement a decent ~VisitIdent~ <2015-07-29 Wed 10:58>
    CLOSED: [2015-07-29 Wed 11:02]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-29 Wed 11:02]
    :END:
    Now, that the ~VisitIdent~ is required by the interface, the client code
    does not type check anymore, which is a good thing.
*** DONE fill in more cases (and prints) to the statement visitor <2015-07-28 Tue 09:28>
    CLOSED: [2015-07-30 Thu 08:38]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-30 Thu 08:38]
    :END:
*** DONE add print into the visitor (stmt and expr perhaps)  <2015-07-28 Tue 09:13>
    CLOSED: [2015-07-28 Tue 09:27]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-28 Tue 09:27]
    :END:
    That's for debugging.
*** DONE make a statement Visitor <2015-07-28 Tue 09:00>
    CLOSED: [2015-07-28 Tue 09:11]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-28 Tue 09:11]
    :END:

*** DONE can one unify all the visitor (in an overloading kind of way)? <2015-07-28 Tue 09:00>
    CLOSED: [2015-07-30 Thu 08:38]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-30 Thu 08:38]
    :END:
    Especially: now I have VisitStmt  and VisitExpr etc, can one just use Visit?
*** DONE create the second argument of the Walk function <2015-07-28 Tue 08:44>
    CLOSED: [2015-07-30 Thu 08:38]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-30 Thu 08:38]
    :END:
    I take again inspiration from   [[~/go/src/github.com/golang/go/src/go/printer/printer_test.go][printer_test.go]].

    In that case: the second argument of the walk function f is an *ast.File

*** DONE create a real visitor as argument for Walk <2015-07-28 Tue 08:39>
    CLOSED: [2015-07-28 Tue 08:44]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-28 Tue 08:44]
    :END:
    The first argument of the walk-function (it is not a method) is a
    visitor. It's created by make.
*** DONE include the absynt package <2015-07-28 Tue 08:27>
    CLOSED: [2015-07-28 Tue 08:29]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-28 Tue 08:29]
    :END:
   like this import ("github.com/MartinSteffen/tiny/absynt")
*** DONE make the test-directory compilable <2015-07-28 Tue 08:23>
    CLOSED: [2015-07-28 Tue 08:30]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-28 Tue 08:30]
    :END:
*** DONE make a real call to walk <2015-07-27 Mon 11:44>
    CLOSED: [2015-07-30 Thu 08:38]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-30 Thu 08:38]
    :END:
**** DONE make a main function etc. <2015-07-27 Mon 11:44>
     CLOSED: [2015-07-27 Mon 12:15]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-27 Mon 12:15]
     :END:
     It seems that it needs to be in a separate directory. I cannot
     call it package main in the same directory, therefore I guess
     a new one is needed. So, perhaps it means, one cannot "test"
     with a main functuon 
     
*** DONE move the stuff to a more official directory <2015-07-21 Tue 15:56>
    CLOSED: [2015-07-21 Tue 16:00]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-21 Tue 16:00]
    :END:

    ok, to ~/go/src/github.com/golang/go
*** DONE Analyze the visitor in the go compiler <2015-07-17 Fri 13:16>
    CLOSED: [2015-07-30 Thu 08:38]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-30 Thu 08:38]
    :END:


**** Visitor infrastructure.


The visitor is contained in the ast-package (in the [[~/go/src/github.com/golang/go/src/go/ast][ast-directory]]). The
code is mainly defined in walk.go.  But it's used in a different
package. The code does not qualify as a ``classic visitor''. As far as I
know, the one from the literature (for languages like Java or C++) involves
that the data structure being visited supports a special method (typically
called ~accept~) in which the visitor ``function'' is handed over. In that
sense it's not clear if that is officially a visitor. It could however be
that one may use the word ``visitor'' more loosely, as any form of
higher-order function that allows to iterate here through an inductively
defined data structure, here the ast, any form of ``fold'' function. We
should therefore look if that's an archtitecture which is supported here.



The data structure being visited is ``the [[~/go/src/github.com/golang/go/src/go/ast/ast.go][ast]]''. The structure is kind of
complex, it also has a form of ``inductive definition'' distinguishing
between various ``non-terminals'' (in particular 3 different kind of nodes,
namely expressions, statements, and declarations). Despite that, the
/constructors/ themselves are ultimately used (i.e., visited) in a rather
unstructured or flat manner. Anyhow, the node (or their specializations) do
not support a  ~Accept~ method which would hand over a visitor.  

Now to the /visitor/ interface. As usual, it's ``abstract'' i.e., an
interface (alternatively perhaps in Java etc, an abstract class). Now, the
method ~Visit~ below gives back a visitor.  That is different from the
situation with the ``pizzas'' etc. There, the visitor would give back an
~Object~ (which is there /not/ meant to represent visitors).



#+begin_example
type Visitor interface {
	Visit (stmt Node) (w Visitor)     // Visitor .-> Node -> Visitor
}
#+end_example

The Node is the catch-all type for all nodes of the ast (i.e., it is
embedded into all the more concrete nodes). 


 What's strange he is also how it is later used, namely in the following
form (at the beginning of the ~Walk~-function):


#+begin_example
func Walk(v Visitor, node Node) {
	if v = v.Visit(node); v == nil {
		return
	}

        ...

#+end_example

Now, we should be careful with the terminology. The ~v~ is the visitor, but
~Walk~ is also something like the visiting function. Note also that the
~Walk~ function takes 2 arguments, the visitor and the tree it is to walk
down.


**** Client code: printer-test 

See also the ``client'' code. The following snippets are taken from
[[~/go/src/github.com/golang/go/src/go/printer/printer_test.go][printer_test.go]] in the ~printer~ package. This one actually is the /only/
use of the ~Walk~-function and the visitor I found there. There are two
things to do: define the visitor, and then using it, by passing it to the
Walk function. In order to be a visitor, it must satisfy the ~Visitor~
interface. The only thing required there is to implement the ~Visit~-method
(and there is, as said, no ~Accept~ method in the nodes of the ast). So
it's the combination of both the data type (basically a channel) plus the
visit-method that makes it to the visitor infrastructure.


#+begin_example
type visitor chan *ast.Ident   

func (v visitor) Visit(n ast.Node) (w ast.Visitor) {
	if ident, ok := n.(*ast.Ident); ok {  // ``special assignment'' for type assertion, ok is a boolean
		v <- ident  // send to channel v
	}
	return v
}
#+end_example


Note that the visitor argument ~v~ is not even a struct, it's a channel
(but I don't know what all is allowed). But indeed, it's some reference
type that supports the ~Visit~ function. Also the receiver type, the
argument type and the return type are as requested by the Visitor
interface. This ``function'' (represented by the visitor-references) is of
type

#+begin_quote
  Visitor .-> Node -> Visitor
#+end_quote

The syntax of the if-statement is not too transparent. the ~<-~ syntax can
mean send or receive. But since on the left-hand side there's a channel,
it's /sending/.  Now, ~ast.Ident~ is just one kind of node, and
~n.(*ast.Ident)~ is a type assertion. However, it's a ``special'' one
because it's used in a special kind of assignment. In this case, no panic
occurs.


#+begin_example

func idents(f *ast.File) <-chan *ast.Ident {
	v := make(visitor)     // due to the above method, this results in a Visitor
                               // initial value of the ``fold''.
	go func() {
		ast.Walk(v, f) // start the visit   
		close(v)       // close the channel
	}()
	return v
}

#+end_example     
It seems that this basically is the /only/ use of the visitor and the walk
function /at all/. The rest of the file (and also elsewhere) does not make
use of it. What is also interesting is the asynchronous nature of the
visitor.

**** ``Functional view''



The ~Walk~ function corresponds to a ``fold'' function, except that it is
imperative. In this case, because it uses a channel. The channel can at
least conceptually seen as ``list''. Let's assume that. The fold-function
would be for instance of the type ~(string list -> node -> string list) ->
string list -> node tree -> sting list~.  The list of strings corresponds
to the channel here as far as the type is concerned. On the
go-implementation, the are a few differences. Some, probably, could also be
adapted if one wanted a moe functional way of representing the program, or
a closer parallel. One is that the ``initial value'' is not handed over a
argument. In the functional analogue, the initial value would be the empty
list. Here, the channel is ``initialized'' to be empty, as well.  Another
thing which is different: here, we distinguish between the tree and its
nodes. In the go-implementation, the nodes and the tree are basically the
same. The concrete ~Visit~-function here is a /concrete/ function being
used in the iteration, which would be of time ~string list -> node ->
string list~. In the go implementation, also the analogue to the string
list, i.e., the ``channel'' is handed over as first argument, however, as
``receiver'' of a the ~Visit~-method. Note also: while the ``second''
argument is a node, which represents the tree here, the node argument is
used in its role as the current node constructor, only, not as the whole
tree. at last as the reaction of is concerned.  Finally, the implementation
is kind of functional, in that the channel (which is the concrete visitor)
is returned from the ~Visit~ function.

All in all, the implementation resembles very closely how one functionally
would implement higher-order function doing something on the nodes of a
tree.



 


**** Misc


- First the interface: The "interface { ... }" is an interface type, the
  whole thing is a type declaration.  Inside the braces it the method
  specification. [It's a bit unclear why we can leave out ";" but ok]. The
  next one is the method name Accept, and  the signature    

                (stmt Stmt) (w Visitor)  

  https://golang.org/ref/spec#Signature

  This one is more stricky. The signature is of one of two forms:
  Parameters or Parameters Results. The signatures are described in
  connection with function types (there are examples). Even if not really
  explaned, the Visitor is the return type.
  

  






*** DONE Analyze the ``Car'' visitor <2015-07-17 Fri 15:07>
    CLOSED: [2015-08-07 Fri 12:43]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-08-07 Fri 12:43]
    :END:

The following is an analysis of the code found at
https://gist.github.com/f0624e7760aacdc96b42.git. The structure is a bit
different, in particular the data structure being visited (see for instance
the interface ~CarPart~ below) supports an accept-function (which is
``standard''). One distiguishes best between the code for the data
structures (including the infrastructure to support ``visitors'') and the
client code, that makes use of the stuff, i.e., that provides a /concrete/
data structure, a /concrete/ visitor (and let it run).

**** Data structures

Let's start with the data structure itself, the car parts: 

#+begin_example
type CarPart interface {   
    Accept(CarPartVisitor) 
}
#+end_example


The data structure is /abstract/, just an interface. Crucial is the
presence of an accept-method, that accepts the corresponding visitor, with
the following  interface ~CarPartVisitor~:


#+begin_example
type CarPartVisitor interface {
    visitWheel(wheel *Wheel)
    visitEngine(engine *Engine)
}
#+end_example


The correspondent type in the ast of before is the ~Visitor~
interface. There are a number of differences, though. First, the
~CarPartVisitor~ interface requires /two/ visit-functions.  The intention
is (indicated also by its name) that the ~CarPartVisitor~ is used to
``visit'' car parts. However, car parts is only an interface, as well,
i.e., it's abstract. Therefore, what is /concretely/ to be visited are
instances of the ``sub-classes'' of ~CarPart~. Of course, there's no
subclassing here. What matters is elements that match the ~CarPart~
interface:

So, that is the classic visitor structure: The data structure supports an
accept function which takes the visitor as argument, and in term the
visitor has a visit-function, which takes data-structures as argument,
i.e., here ~CarPart~'s. Being abstract, the visit-function is /split/ into
two cases, handling concrete car parts. Perhaps that is a (small) price to
pay for the absence of /method overloading/ that we one has to choose two
differnent names for the two visit-functions. With this kind of
overloading, one might have gotten away with just calling both just ~visit~.

Now, as mentioned, with duck typing (and the ~CarPart~-interface given as
is) car parts are /defined/ as those elements which accept a car-part
visitor!  That would some stucts, namely cars, engines, and wheels

#+begin_example
//------------------------- car part: wheel ---------
 type Wheel struct {
    Name string
}
 
func (this *Wheel) Accept(visitor CarPartVisitor) {
    visitor.visitWheel(this)   ``function application'' via call-back
}

//------------------------- car part: engine ---------

type Engine struct {}
 
func (this *Engine) Accept(visitor CarPartVisitor) {
    visitor.visitEngine(this)   // ``function application'' via call-back
}
 
//------------------------- car part: car ---------
type Car struct {
    parts []CarPart
}
 
func NewCar() *Car {
    this := new(Car)
    this.parts = []CarPart{
        &Wheel{"front left"},
        &Wheel{"front right"},
        &Wheel{"rear right"},
        &Wheel{"rear left"},
        &Engine{}}
    return this
}
 
func (this *Car) Accept(visitor CarPartVisitor) {
    for _, part := range this.parts {
        part.Accept(visitor)
    }
}
 
#+end_example

Note that, as requested by the car part interface, the car parts must
support the ~Accept~ method. That means, the data structures themselves
must be ``changed'' to support the visitor pattern. In go, the method can
be externally ``attached'' to the data structure, but due to scope
restriction, one cannot add those methods from outside a given package
(maybe not even outside a file).


A side remark on the design: as mentioned above, the ~CarPartVisitor~
support visit functions for two concrete car parts, namely wheels and
engines, and they are called differently. I think a different design would
be possible two, using only one single ~visit~-function, with then the
/abstract/ ~CarPart~ as type of the parameter, not the concrete struct
types. If doing so, the ``dispatch'' to the different cases needs to by one
inside (i.e., at the start) of the body of that method. That would be done
/switching/ on the different options (with the help of the special form of
/type assertions/, like ~y := cp.(type)~). It would be a way of achieving
the same --dispatch on the type argument-- as with method overloading
(which we don't have in go) except that we'd actually had only one
~visit~-method.

Note finally: there are /three/ concrete types (i.e., record types) which
are car parts (namely those which support the accept method), wheels,
engines, but also cars themselves. However, the visitor ~CarPartVisitor~
covers only the wheels and the engine. The reason is: one ~Car~ already has
a kind of ``visitor'' functionality in the following sense: the car
basically a ``list'' of car-parts (as a slice). For slices, there is
already an official iteration pattern, the for-loop in connection with the
range-construct. So, this part of the data structure is ``iterated over''
not with the ``visit/accept'' pattern. Besides that: it is not really clean
design that cars are also car part (no just because in ``real life'' it
sounds strange). In an inductive definition or in a functional language,
the type of cars would not be ``merged'' with that of its parts.

**** Client code

So far everything was abstact, we have some infrastructure to run a
``fold''.  So we need to declare / define a concrete struct implementing
the visitor (the struct is declared, but the methods, attached to it, are
defined).


#+begin_example
type GetMessageVisitor struct{
    Messages []string
}
 
func (this *GetMessageVisitor) visitWheel(wheel *Wheel) {
    this.Messages = append(this.Messages, fmt.Sprintf("Visiting the %v wheel\n", wheel.Name))
}
 
func (this *GetMessageVisitor) visitEngine(engine *Engine) {
    this.Messages = append(this.Messages, fmt.Sprintf("Visiting engine\n"))
}

#+end_example


#+begin_example
func main() {
    car := NewCar()
    visitor := new(GetMessageVisitor)
    car.Accept(visitor)
    fmt.Println(visitor.Messages)
}

#+end_example

**** An equivalent functional data structure

The above structure is rather clumsy when compared to functional
representation with higher-order functions and pattern matching. The
example is also slightly too simple. The visitors are used in particular
also to iterate through a /recursive/ or /inductively given/ data
structures. The parts of a car here are not recursive. The only recursive
part is the fact that cars have a field implemented as slice (of car
parts). In connection with that: the fact that cars are also car parts
would allow that cars could contains cars as parts, which would add an
element of recursive definition here. But that's not intended,
pragmatically at least. So the only recursive part here, which is the
slice, is not actually solved following the accept/visit-structure of the
visitor pattern. Instead, the slice is iterated over using the for-loop in
connection with the range-construct. Anyhow, the data type in a
functional/inductive representation looks as follows, where I use list as
replacement for the slice in go:

#+begin_example
   type carpart = 
     | Engine of unit 
     | Wheel of string


   type car = carpart list  
#+end_example

Unlike the representation in the go code, ~car~ here is not at the same
time a ~carpart~. If one wanted a 100% correspondence, one had to make the
two type definition mutually recursive, but it is clearly not what the
example is intended to model.

**** DONE Why is there no ~visit~-function for cars? <2015-07-17 Fri 19:57>
     CLOSED: [2015-07-18 Sat 11:15]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-18 Sat 11:15]
     :END:

As explained, there are three concrete car parts, but car part visitor has
only 2 two methods, i.e., it can only react to two of them (engines and
wheels, but not cars). It's because the car (which is strangely also a car
part), is nothing else than a ``list'' in the form of a slice. A visitor is
supposed to iterate through that thing. But 1) a slice is not a car part
insofar it does not support an ``accept'' method (but cars
do). Furthermore, 2) there is an official way to iterate through a slice,
that's the for-loop in connection with the range-construct. That's what's
done here.



*** TODO Check the Pizza visitors <2015-07-21 Tue 16:23>
    :PROPERTIES:
    :ID:       cb8e5a9a-0833-4b80-b6fa-dd8573e97137
    :END:

    
    One of the most extended code examples (perhaps the final design) can
    be found under there [[~/Collectionofreposes/SOFTTECH/trunk/lehre/javakurs/uebungen/code/uebung5/ausdruecke5][under ``softtech'']] (and other directories
    there). Also there, the data structures(like expressions) support a
    method ~accept~. It seems that concrete vistitors return objects of
    type ~Object~ (more concretely the functions which are here called
    ``visit'' functions), and als the ~accept~-method.  Sometimes some
    casts are necessary therefore. It is, however not giving back a
    visitor.

    

*** DONE in the ``Pizza-visitor'': (ExpressionVisitor): return type <2015-07-21 Tue 16:49>
    CLOSED: [2015-07-21 Tue 17:03]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-21 Tue 17:03]
    :END:
    In that visitor, the functions forConst, forOder, forUnd return Objects
    Will that actually be a visitor again, or something else. 
    
    Perhaps it can be seend in Eval_d wich is a concrete visitor for expressions.
    
    Therefore it must have 3 functions. What he returns in the forOrder case is
    
    That is not not yet the real thing, there is SetEval_V extends Eval_D
    or Int_Eval and BoolEval_V. Those then finally give back the real
    result. All of them a special cases of the evaluation visitor. The
    reason why it gives back objects here is because it gives back
    different values in different situations., namely a set, a boolean or
    an it depending on how the stuff is interpreted. So that has to do with
    the lack of universal polymorphism (at that time).  Anyway, what is
    /not/ given back is a visitor, that's clear.
    
*** TODO expression visitor: forUnd why do they have 2 arguments? <2015-07-21 Tue 16:50>
    :PROPERTIES:
    :ID:       594f1417-6165-41ae-a036-95dc07d8795b
    :END:
    Perhaps, it's a better design.  

*** TODO duck typing  ``marker'' functions: accept <2015-07-18 Sat 13:45>
    :PROPERTIES:
    :ID:       20212731-e476-4f8d-b92e-a10486d758fa
    :END:

    Currently the subtyping is done by some marker functions. Now that
    we have the accept functions: do the make the older name based markers
    superfluous?

    Currently we leave them in, we experiment with it later 
*** TODO add the argument to the accept functions for statements <2015-07-18 Sat 14:13>
    :PROPERTIES:
    :ID:       d4f24852-d0a7-4619-8fa3-5e13ac37b074
    :END:

*** DORMANT perhaps install gocc <2015-04-18 Sat 06:38>
    CLOSED: [2015-07-27 Mon 12:16]
    :LOGBOOK:
    - CLOSING NOTE [2015-07-27 Mon 12:16] \\
      unklar
    :END:

*** DONE port it to ssh: change the url? <2015-07-17 Fri 08:47>
    CLOSED: [2015-07-17 Fri 08:50]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-17 Fri 08:50]
    :END:


    git remote -v 

    Currently origin	https://github.com/MartinSteffen/tiny (fetch)
              origin	https://github.com/MartinSteffen/tiny (push)



    git remote set-url origin git@github.com:USERNAME/OTHERREPOSITORY.git

    Take care: there's a ":"




*** DONE construct a concrete Stmt <2015-07-24 Fri 08:53>
    CLOSED: [2015-07-24 Fri 11:24]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-24 Fri 11:24]
    :END:

*** DONE construct a SimpleExpr <2015-07-24 Fri 10:52>
    CLOSED: [2015-07-24 Fri 11:24]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-24 Fri 11:24]
    :END:

    For the grammar, a clear representation is   [[~/teaching/compilers/tiny/src/ocaml/absynt.ml][absynt.ml]]

**** DONE construct a term <2015-07-24 Fri 10:59>
     CLOSED: [2015-07-24 Fri 11:23]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-24 Fri 11:23]
     :END:


**** FIXED What's wrong with ID, and the factor <2015-07-24 Fri 11:06>
     CLOSED: [2015-07-24 Fri 11:20]
     :LOGBOOK:
     - CLOSING NOTE [2015-07-24 Fri 11:20]
     :END:

     Everything was fine in the data structure itself. But for the construction:

     One needs to use ~var f = &ID{I:"s"}~ with ~&~. The receiver of the methods
     are references to those things. 


*** DONE what's the meaning of the return ``type'' (w Visitor) <2015-07-24 Fri 08:20>
    CLOSED: [2015-08-01 Sat 09:22]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-08-01 Sat 09:22]
    :END:
    In the file visitor2.go: One can actually return w or ``call it'' but
    it's unclear what it   

    Duplicate entry

*** DONE related to that: why can one write just return? <2015-07-24 Fri 08:48>
    CLOSED: [2015-08-01 Sat 09:22]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-08-01 Sat 09:22]
    :END:
    In the visitors, both return v and return type check.
    Probably short hand for ``self''
*** DONE add a Node to the ast.go <2015-07-17 Fri 09:12>
    CLOSED: [2015-07-17 Fri 09:18]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-17 Fri 09:18]
    :END:
*** DONE visitor: where does the Node come from <2015-07-17 Fri 09:09>
    CLOSED: [2015-07-17 Fri 09:12]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-17 Fri 09:12]
    :END:
    It's at least not in the same file, probably it's package wide
    so it's in ast.go
*** DONE make a better README.md <2015-07-16 Thu 09:54>
    CLOSED: [2015-07-17 Fri 08:24]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-17 Fri 08:24]
    :END:
     see http://stackoverflow.com/questions/8655937/github-readme-and-readme-md
*** DONE can one open a package <2015-07-16 Thu 08:11>
    CLOSED: [2015-07-17 Fri 08:25]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-17 Fri 08:25]
    :END:

    This one is not nice

	f :=    &ast.NUMBER{1}


	But it seems that it's not forseen





*** DONE where is the ast in ml <2015-07-20 Mon 14:27>
    CLOSED: [2015-07-20 Mon 14:29]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-20 Mon 14:29]
    :END:
    It's in ~/ocaml/go <2015-07-20 Mon 14:29>
*** DONE just make a functional implementation, to make the types clearer <2015-07-18 Sat 09:02>
    CLOSED: [2015-08-01 Sat 09:22]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-08-01 Sat 09:22]
    :END:
*** DONE capitalize the rest in ast <2015-07-16 Thu 09:03>
    CLOSED: [2015-07-16 Thu 09:09]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-16 Thu 09:09]
    :END:

*** FIXED why does the import in somename.org not work <2015-07-16 Thu 08:05>
    CLOSED: [2015-07-16 Thu 08:50]
    :LOGBOOK:
    - CLOSING NOTE [2015-07-16 Thu 08:50] \\
      some names were not exported
    :END:
    It's really weird. This one works

    import ("fmt"
	"ast")


   I would have thought it's

    import ("fmt"
	"github.com/MartinSteffen/tiny/ast")


   but those give the above errors 


   => It seems to related to the fact that some of the stuff is not

      exported

     After changing the type from number to int (which is the same but definitely
     global, I get the error

      ./somename.go:16: implicit assignment of unexported field 'n' in ast.NUMBER literal

      That means (I assume) that somehow NUMBER (or more probably it's fields)
      are not known outside


**** DONE how does one export stuff (types, and fields of constructors)  <2015-07-16 Thu 08:40>
     CLOSED: [2015-07-16 Thu 08:50]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 08:50]
     :END:

     It's done via capitalization. I changed the type and the constructor, then it works
**** DONE make it number instead of int again and export <2015-07-16 Thu 08:40>
     CLOSED: [2015-07-16 Thu 08:50]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 08:50]
     :END:
     -> Make it to "Number".
     -> make the field capitalized as wellx


**** DONE install ast.go <2015-07-16 Thu 08:24>
     CLOSED: [2015-07-16 Thu 08:38]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 08:38]
     :END:
     
     That might be the source of the problems now: the somename may not find
     it because the error is in ast.go, not in somename.go?

*** FIXED make somename.go compile: arguments for constructors  <2015-07-16 Thu 08:21>
    CLOSED: [2015-07-16 Thu 09:00]
    :LOGBOOK:
    - CLOSING NOTE [2015-07-16 Thu 09:00] \\
      the ast was not exported properly (and perhaps the package name of ast was
      unfitting and ast not installed.
    :END:
    
    It's weird, seems there is some inconsistencies. If I program in
    ast/ast.go , (which I currently call package go), then I can do

   func main () {
  	f :=    &NUMBER{1}
	fmt.Println(f)
	
   }
   
   inside the file ast.go. If I do that in the other package test/somename.go
   writing 

   func main () {
  	f :=    &ast.NUMBER{1}
 	fmt.Println(f)
	
   }

   then the compiler complains that he cannot figure out the arg.

   Perhaps that's because the package name etc are not yet fully clarified
   and it does not find the "ast"



   

*** DONE add to the org-path <2015-07-16 Thu 07:55>
    CLOSED: [2015-07-16 Thu 09:10]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-16 Thu 09:10]
    :END:
    ok
*** DONE make it to a worspace/package or whatever <2015-07-15 Wed 13:32>
    CLOSED: [2015-07-16 Thu 07:50]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-16 Thu 07:50]
    :END:

    See https://golang.org/doc/code.html

    it needs a workspace.

    But the workspace is just ~/go and the point where GOROOT shows

    


*** TODO can one access the stuff inside the package ast itself? <2015-07-16 Thu 10:38>
    :PROPERTIES:
    :ID:       f8e76229-e102-48ee-bed8-78c37e2285fa
    :END:

**** DONE if yes, would it help: can one make use of it? <2015-07-16 Thu 10:38>
     CLOSED: [2015-08-01 Sat 09:22]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-08-01 Sat 09:22]
     :END:


**** DONE add print_Number <2015-07-16 Thu 14:15>
     CLOSED: [2015-07-16 Thu 14:17]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 14:17]
     :END:
**** DONE add Print_Factor <2015-07-16 Thu 14:12>
     CLOSED: [2015-07-16 Thu 14:17]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 14:17]
     :END:
**** DONE add Print_Term <2015-07-16 Thu 14:00>
     CLOSED: [2015-07-16 Thu 14:09]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 14:09]
     :END:

**** DONE add print_add_op <2015-07-16 Thu 14:00>
     CLOSED: [2015-07-16 Thu 14:32]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 14:32]
     :END:
**** DONE add Print_SimpleExpr <2015-07-16 Thu 13:36>
     CLOSED: [2015-07-16 Thu 14:00]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 14:00]
     :END:

**** FIXED Print_Term(se.T)  // error <2015-07-16 Thu 13:54>
     CLOSED: [2015-07-16 Thu 13:58]
     :LOGBOOK:
     - CLOSING NOTE [2015-07-16 Thu 13:58] \\
       ok, TERM instead of Term
     :END:

     Inside Print_SimpleExpr: bug

     perhaps duplication?
**** FIXED print_Simple_Expr leads to an compile error <2015-07-16 Thu 13:43>
     CLOSED: [2015-07-16 Thu 13:45]
     :LOGBOOK:
     - CLOSING NOTE [2015-07-16 Thu 13:45] \\
       Simply pointer type instead of struct
     :END:

**** DONE add Print_Compare_Op <2015-07-16 Thu 13:36>
     CLOSED: [2015-07-16 Thu 13:39]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 13:39]
     :END:
**** DONE add Print_Expr <2015-07-16 Thu 13:25>
     CLOSED: [2015-07-16 Thu 13:34]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 13:34]
     :END:
*** TODO make more careful name conventions <2015-07-16 Thu 14:28>
    :PROPERTIES:
    :ID:       523a94a3-0d10-4293-a381-b45e42ec9418
    :END:
**** DONE grouping: can one group the marker methods inside the ()? <2015-07-16 Thu 14:30>
     CLOSED: [2015-08-01 Sat 09:23]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-08-01 Sat 09:23]
     :END:
     of course it may not be worth it.

     Nope
*** TODO Stmt etc.: use slices <2015-07-16 Thu 14:28>
    :PROPERTIES:
    :ID:       cb7b7ca9-481a-4d4f-881b-96241e7776f0
    :END:
**** DONE can one make the functions mutually recursive <2015-07-16 Thu 12:01>
     CLOSED: [2015-07-16 Thu 12:31]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 12:31]
     :END:
     yes, that seems allowed

**** DONE activate some client code <2015-07-16 Thu 12:03>
     CLOSED: [2015-07-16 Thu 14:17]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 14:17]
     :END:
**** FIXED interface receiver:  why is it not possbible to do func (Stmt) print_stmt () {..} <2015-07-16 Thu 11:25>?
     CLOSED: [2015-07-16 Thu 11:51]
     :LOGBOOK:
     - CLOSING NOTE [2015-07-16 Thu 11:51] \\
       methods don't work (the receiver cannot be abstract) but function work
     :END:
     Well, I fuess we need an argument. But that's not the only error

    Stmt: it must not be a pointer or interface type and it must be
    declared in the same package as the method. 

    so, interfaces =abstract 

***** DONE can one make a function instead of a method? <2015-07-16 Thu 11:42>
      CLOSED: [2015-07-16 Thu 11:51]
      :LOGBOOK:
      - State "DONE"       from "TODO"       [2015-07-16 Thu 11:51]
      :END:
      Ok, at least one can pass that as argument
**** DONE how did the "go" implementation walker implementation work? <2015-07-16 Thu 11:33>
     CLOSED: [2015-08-01 Sat 09:23]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-08-01 Sat 09:23]
     :END:
      This one did not have problems.

      Yes


*** TODO external visitor via embedding or wrappers or something? <2015-07-18 Sat 12:21>
    :PROPERTIES:
    :ID:       282c8a9a-cc59-42c2-bd6a-9f15b04903d6
    :END:
    is that possible? Currently I did not do that, just a more direct implementation

*** TODO add recursion <2015-07-18 Sat 17:41>
    :PROPERTIES:
    :ID:       350d7ad8-58b7-4085-a0ed-1cc36a48afd9
    :END:

    I think that's the piece which is missing.

**** TODO where should it be added (see the go ast walker) <2015-07-18 Sat 17:46>
     :PROPERTIES:
     :ID:       287526cd-5e79-4753-a79e-fde39aa8d989
     :END:

     type Visitor interface {
	Visit (stmt Node) (w Visitor)   
}  

   The visitor is the return. But there is no accept 
***** DONE give back a tuple? is that ok? <2015-07-18 Sat 17:53>
      CLOSED: [2015-08-01 Sat 09:23]
      :LOGBOOK:
      - State "DONE"       from "TODO"       [2015-08-01 Sat 09:23]
      :END:
      No, not really
*** DONE make a visitor <2015-07-17 Fri 09:32>
    CLOSED: [2015-07-27 Mon 12:17]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-27 Mon 12:17]
    :END:
*** TODO make a visit/accept visitor here <2015-07-18 Sat 11:41>
    :PROPERTIES:
    :ID:       d0be6437-d614-45f3-95f7-774a2ed98ca7
    :END:
**** TODO can one make the additional infra-structure in a sep. file <2015-07-18 Sat 12:01>
     :PROPERTIES:
     :ID:       b8447063-924c-45ed-9d05-07477152115f
     :END:
     It still would not solve the problem, I assume, that one let the
    original ``package'' untouched. But at least the file. I am pretty sure
    that one cannot define it outside the package.

***** TODO try to add an Accept method to Stmt <2015-07-18 Sat 12:09>
      :PROPERTIES:
      :ID:       fe8d1cf0-cb17-48e2-babf-571721593852
      :END:
      To figure out if I can do it in the same package but different file.

      Ok, the latter one does not work, because it _needs to be done for
      the Stmt interface. It may be possible
****** DONE Add the correct type <2015-07-18 Sat 14:51>
       CLOSED: [2015-07-18 Sat 14:54]
       :LOGBOOK:
       - State "DONE"       from "TODO"       [2015-07-18 Sat 14:54]
       :END:
****** TODO figure out the right type <2015-07-18 Sat 14:54>
       :PROPERTIES:
       :ID:       030b3955-d1c3-4f63-af63-14710661cfe6
       :END:

       we are given

         stmt ::= IF exp ....

       so IF must accept a Stmt_Visitor.
       
       This is what we have done anyway: the IF constuctor is a statement 
       and therefore accepts a StmtVisitor. The problem starts with 
       its first component, the expression. expressions are not of
       type statement. Therefore they also don't support a visit_Exp.

       note: of course: if the first component of the IF were a stmt
       we could also not just do

         visitor.visit_stmt(this)

      we simply don't have those functions.

      Probably, we need a generic visitor 



That does not work
type Visitor interface {     // new attempt
	visit_Stmt (s Stmt)  // just a dispatch
	visit_Expr (e Expr)  // just a dispatch
}

func (s *Stmt) visit_Stmt () {}
func (s *Expr) visit_Expr () {}


****** TODO why not manke Visitor a super-interface? <2015-07-18 Sat 16:10>
       :PROPERTIES:
       :ID:       7da8eac3-d13e-44dd-b622-ff2cecfc657b
       :END:
       I guess that might work, the question is, does it fit with duck typing

       The problem also is: everything works fine with concrete stuff
       gluing stuff to

       IF / WhEN so visit_IF is ok, but not visit_Expr because Expr is not a struct. 
       We cannot glue anything to Exp.

****** TODO  Make a general visitor +  general dispatch <2015-07-18 Sat 15:28>      
       :PROPERTIES:
       :ID:       329a53f1-dc49-40d9-8a2a-d35af8622076
       :END:




**** DONE simplify the syntax: stmt no slice <2015-07-18 Sat 15:33>
     CLOSED: [2015-07-18 Sat 15:58]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-18 Sat 15:58]
     :END:
**** TODO do the stmt slices back in <2015-07-18 Sat 15:33>
     :PROPERTIES:
     :ID:       3e183a03-49d7-407e-ae9b-f3356452807d
     :END:
**** DONE can one make a less flat visitor <2015-07-17 Fri 09:33>
     CLOSED: [2015-07-18 Sat 14:14]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-18 Sat 14:14]
     :END:

     The visitor of go is flat.  My recursive function was not. So, I would
     like a similar design here.

     In my file, there's a function there Print_<nonterminal> for all of
     those. Probably, there'd b a visitor for all of those =>
     
     Let's make a visitor for all Print_X.

     That would probably mean whe need a visitor interface for all the
     phrases.

     Yes, it seems easily possible

**** DONE add a visitor for staments <2015-07-17 Fri 09:59>
     CLOSED: [2015-07-18 Sat 14:14]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-18 Sat 14:14]
     :END:


     What is uncear is how to escape to the other clauses. We have to see about that
     
     Why I need is an visitor, that's done with make(visitor)




**** DONE why is an ``instance'' of visitor a Visitor <2015-07-17 Fri 14:10>
     CLOSED: [2015-07-17 Fri 14:20]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-17 Fri 14:20]
     :END:
     the ast.Walk function requests 2 args (it's a function not a method)

     The first argument is of type Visitor (not visitor), but we hand over
     an element of type visitor.

     Well, it ``glues'' a visitor function to it






**** DONE check some other visitor examples <2015-07-17 Fri 12:22>
     CLOSED: [2015-07-18 Sat 14:14]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-18 Sat 14:14]
     :END:


     https://gist.github.com/francoishill/f0624e7760aacdc96b42

     They use more standard "terminology", what's called "Visit" here is
     called "Accept" there. It's not really an inductive structure, but
     ok. They don't deal with channels.

     CarPart is abstact, so there are no instances thereof.




***** DONE which are implementations (``substypes'') of CarPart <2015-07-17 Fri 12:53>
      CLOSED: [2015-07-18 Sat 14:14]
      :LOGBOOK:
      - State "DONE"       from "TODO"       [2015-07-18 Sat 14:14]
      :END:

      We have nominal subtyping, so we need one with Accept



     

     carpart = 
     

**** TODO are the visitors the (only) way that the go books speak about higher-order programming? <2015-07-17 Fri 12:23>
     :PROPERTIES:
     :ID:       81a61549-405b-43b8-a8da-a6a9f41a136b
     :END:


**** DONE what does make <2015-07-17 Fri 11:41>
     CLOSED: [2015-07-18 Sat 14:15]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-18 Sat 14:15]
     :END:
     one cannot do make (int) for instance 
     
     for slices, maps, channels

    Unlike new, make's return type is the same as the type of its argument, 

    But if make can be done for those things only, the question is what 
    is the function-visitor? I don't think it's a slice. In the example it's
    a channel. It's not necessary connected with the thing we are after.
    IT's just one specific visitor


**** DONE what's the type ov visitor? <2015-07-17 Fri 11:48>
     CLOSED: [2015-07-17 Fri 11:49]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-17 Fri 11:49]
     :END:
     

    ok, it's a channel

      type visitor chan *ast.Ident

      
    
    
**** DONE is there also a _use_ of the concrete visitor <2015-07-17 Fri 10:36>
     CLOSED: [2015-07-17 Fri 10:39]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-17 Fri 10:39]
     :END:
     Yes, the have

#+begin_example
func idents(f *ast.File) <-chan *ast.Ident {
	v := make(visitor)
	go func() {
		ast.Walk(v, f)
		close(v)
	}()
	return v
#+end_example


**** DONE do they have an example of a concrete visitor <2015-07-17 Fri 10:18>
     CLOSED: [2015-07-17 Fri 10:22]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-17 Fri 10:22]
     :END:
     Seems like in printer/printer_test.go there is one 
**** DONE make already now a client code <2015-07-17 Fri 10:00>
     CLOSED: [2015-07-18 Sat 14:15]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-18 Sat 14:15]
     :END:
     for early testing.

**** DONE what would be the functional equivalent to a visitor, implement one <2015-07-17 Fri 09:42>
     CLOSED: [2015-07-17 Fri 09:59]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-17 Fri 09:59]
     :END:

     move to the other repos




     

**** TODO how does the walk-thing go <2015-07-14 Tue 07:57>
     :PROPERTIES:
     :ID:       2eb448cb-e8cd-4911-916e-d33c0a62868d
     :END:

   See 

    ~/Collectionofreposes/GITHGEXTERNALS/go/src/go/ast/


    That's a kind of visitor. It imports the ast 

    It does not seem to do much, it just walks through it. As expected it's
    a recursive function. It takes two argument, the second one is the
    visitor. That's the ``functional'' argument.


*** DONE How to make an iterator over slices <2015-07-17 Fri 07:57>
    CLOSED: [2015-07-17 Fri 08:23]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-17 Fri 08:23]
    :END:
    See page 154: a read-only access: with range 

*** DONE can I make use of that function in the test thing? <2015-07-16 Thu 14:35>
    CLOSED: [2015-07-17 Fri 07:57]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-17 Fri 07:57]
    :END:
*** DONE make a main program in visitor2.go <2015-07-24 Fri 11:27>
    CLOSED: [2015-08-01 Sat 09:24]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-08-01 Sat 09:24]
    :END:
*** TODO make the print-out at least a bit readable <2015-07-16 Thu 14:34>
    :PROPERTIES:
    :ID:       b55634ac-cf19-4e8d-8ed1-588da39887c1
    :END:
*** DONE make a running program making use of a program <2015-07-14 Tue 12:16>
    CLOSED: [2015-08-01 Sat 09:24]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-08-01 Sat 09:24]
    :END:
**** DONE in the parser: how are the nodes created <2015-07-14 Tue 11:38>
     CLOSED: [2015-07-15 Wed 08:04]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-15 Wed 08:04]
     :END:
***** DONE look at standard cases <2015-07-14 Tue 11:51>
      CLOSED: [2015-07-14 Tue 12:16]
      :LOGBOOK:
      - State "DONE"       from "TODO"       [2015-07-14 Tue 12:16]
      :END:

      Here seems one:
-------------------------------------------------------------------------
	case token.SEMICOLON:
  		s = &ast.EmptyStmt{Semicolon: p.pos}
-------------------------------------------------------------------------
    ast is unclear where defined. It's a package, maybe that's what's ment-

    EmptyStmt in the package is 

	EmptyStmt struct {
		Semicolon token.Pos // position of preceding ";"
	}

	So, that's then the syntax to create a node, here 



***** DONE what does the make function do in go? <2015-07-14 Tue 11:39>
      CLOSED: [2015-07-15 Wed 08:04]
      :LOGBOOK:
      - State "DONE"       from "TODO"       [2015-07-15 Wed 08:04]
      :END:
      it's similar to new:  works for type slice, map, or chan (only). 
      It not needed here
***** CANCELLED new: can one have arguments <2015-07-14 Tue 11:45>
      CLOSED: [2015-07-15 Wed 08:04]
      :LOGBOOK:
      - CLOSING NOTE [2015-07-15 Wed 08:04]
      :END:
***** DONE why does new not have a sep. category in the ast <2015-07-14 Tue 11:46>
      CLOSED: [2015-07-14 Tue 11:47]
      :LOGBOOK:
      - State "DONE"       from "TODO"       [2015-07-14 Tue 11:47]
      :END:
      it's a built-in function, probably that's the reason
***** DORMANT if new is built in, how is it implemented <2015-07-14 Tue 11:47>
      CLOSED: [2015-07-15 Wed 08:04]
      :LOGBOOK:
      - CLOSING NOTE [2015-07-15 Wed 08:04]
      :END:
**** DONE is the ``inductive structure'' of the AST flat or not? <2015-07-14 Tue 08:51>
     CLOSED: [2015-07-15 Wed 08:05]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-15 Wed 08:05]
     :END:
     For the switch-construct it is. It needs not be, though
**** DONE what's the node.(type) there? <2015-07-14 Tue 08:08>
     CLOSED: [2015-07-14 Tue 08:35]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-14 Tue 08:35]
     :END:
     node: Node. The node is the top-``ìnterface''

     In the ast.go, there are a few comments like

	Type   Expr      // asserted type; nil means type switch X.(type)
   so probably that is a general go language thing.


   Anyway, it's a special form (or variant) of a type assertion. It's a
   type switch. It's indeed used om a big switch-case.

**** DONE how does the case switch in walk.go works <2015-07-14 Tue 08:35>
     CLOSED: [2015-07-14 Tue 11:35]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-14 Tue 11:35]
     :END:
     
     It uses a type switch switch n := node.(type). That gives various
     cases. It seems that the case-switch structure is flat , despite the
     fact that there are substructures of Node.

***** DONE flat case switch in walk.go ? <2015-07-14 Tue 09:37>
      CLOSED: [2015-07-14 Tue 11:35]
      :LOGBOOK:
      - State "DONE"       from "TODO"       [2015-07-14 Tue 11:35]
      :END:

      Is it true that the case switch is flat? -> yes

**** DONE what's the ``type'' of n in switch n := node.(type)? <2015-07-14 Tue 08:37>
     CLOSED: [2015-07-14 Tue 09:32]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-14 Tue 09:32]
     :END:
     It seems that this is _not_ fixed. It seems that n is just the node
     which is represented by n. That can be seen in walk.go by looking at
     the different cases in the case switch. Depending on the case, one
     makes use of things like n.Doc or n.Low. For instance, in case n is of
     type *Field (i.e., a reference to a Field): the type Field is a
     struct, i.e., a struct type (or record type).  Now, fields are structs
     which have a ``field'' like Doc. In a functional language, it's like

     Field of CommentGroup *  Ident *  Expr * BasicLit * CommentGoup (1)

    If of course not a tuple but a record, but ok.

     That one is a Node. Let's ignore the sub-structures, because they
     don't play a role, probably in the switching. Anyhow: the particular
     node constructed via Field has 5 args, as given above in (1). In ms, they would be matched like

     match n with
       Field(c1,i,e.b.c2) -> 

    which means the names are given locally. In the kind of programming here it's with 
    selectors like

      n.Doc 


      depending on the type switch case, different selectors apply of course.
    

     


**** DONE what's struct ( interfaces ) <2015-07-15 Wed 08:14>
     CLOSED: [2015-08-01 Sat 09:24]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-08-01 Sat 09:24]
     :END:
     It's in the ast of go. We shoold also look at the book and the spec
*** TODO AST: Fields why are some of the things as pointers and some not <2015-07-14 Tue 08:58>
    :PROPERTIES:
    :ID:       b0001adb-a6ce-46d9-a72c-1f26a97bc5d8
    :END:
**** DONE Constructors: it seems that in AST, they ``mimic'' those: how to set them <2015-07-14 Tue 09:16>
     CLOSED: [2015-07-15 Wed 08:06]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-15 Wed 08:06]
     :END:
     
     One may see that for instance for Field: it's a struct type, and has a
     number of fields. That seems to me like describing the result of
     applying a constructor. The question then is how to do that?

     I guess, one may simply write some functions, or better methods.

     I'd actually expect that a parser should have some such
     functions/methods, one should check there ->
     
     yes.

     It seems like CONSTRUCTOR { file : value}
***** DONE check the parser for constructors (or ast) <2015-07-14 Tue 09:21>
      CLOSED: [2015-07-15 Wed 08:06]
      :LOGBOOK:
      - State "DONE"       from "TODO"       [2015-07-15 Wed 08:06]
      :END:
*** TODO look at how the parser works <2015-07-14 Tue 07:55>
    :PROPERTIES:
    :ID:       eb9cad91-068d-4142-bfa5-03dedb8af326
    :END:
*** DONE look at the example_test.go program <2015-07-14 Tue 07:52>
    CLOSED: [2015-08-01 Sat 09:24]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-08-01 Sat 09:24]
    :END:
*** DONE constructors / inductive definition in go <2015-07-14 Tue 07:26>
    CLOSED: [2015-08-01 Sat 09:23]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-08-01 Sat 09:23]
    :END:
*** DONE how can one implement the AST? <2015-07-12 Sun 18:22>
    CLOSED: [2015-07-14 Tue 07:18]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-14 Tue 07:18]
    :END:
    I check via the go ast 
*** DONE what's golex go lex, why don't I have it <2015-07-12 Sun 13:59>
    CLOSED: [2015-07-12 Sun 14:23]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-12 Sun 14:23]
    :END:

    they have go tool yacc, but no lex, but there it is.

    "https://github.com/cznic/golex"

    go get lex did it! 

** Go language questions

   See also the go.org file

*** DONE make (``channel''): what is the capacity of a made channel? <2015-07-29 Wed 07:28>
    CLOSED: [2015-07-29 Wed 07:29]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-29 Wed 07:29]
    :END:
    If the capacity is absent, it's a synchronous channel. 
*** TODO how is the AST of go designed <2015-07-13 Mon 13:05>
    :PROPERTIES:
    :ID:       eda1e959-57fd-44cb-984c-5f96175734b4
    :END:
    
    Probably they use structural subtyping. There are 4 important
    interfaces. Probably one can illustrate it as follows:

    
                   Node
                /   |    \
	    Exp    Stmt  Decl

 
The language is probably readable at

   https://golang.org/ref/spec     


For instance for the statements

Statement =
	Declaration | LabeledStmt | SimpleStmt |
	GoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt |
	FallthroughStmt | Block | IfStmt | SwitchStmt | SelectStmt | ForStmt |
	DeferStmt .

SimpleStmt = EmptyStmt | ExpressionStmt | SendStmt | IncDecStmt | Assignment | ShortVarDecl .


That does not 100% correspond to what one sees in the implementation. I
would rather like to come up with a scheme, which is more or less schematic
_AND_ corresponds 100% to the grammar. We should have a look at 2 things,
the grammar _and_ the ML ast. I guess the better starting point is the
ast. That should very much determine the tree, because it's a tree.




**** TODO make a walk-style visitor for the tiny-ast <2015-07-22 Wed 11:32>
     :PROPERTIES:
     :ID:       fca59627-5abb-48bd-884d-9660ba7c9217
     :END:

     That's done in the package [[~/go/src/github.com/MartinSteffen/tiny/absynt][absynt]]. I had been called ast2 before, but
     perhaps that's a unallowed package name. It is modelled similar than
     the one for [[~/go/src/github.com/golang/go/src/go/ast][go itself]], especially the file [[~/go/src/github.com/golang/go/src/go/ast/walk.go][walk.go]].  It's not modelled
     after the visit-accept pattern (I might try that later again, but it
     was very confusing).

**** DONE make it compile <2015-07-23 Thu 11:27>
     CLOSED: [2015-07-23 Thu 11:31]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-23 Thu 11:31]
     :END:

     Still a lot of dummy code.
**** DONE make already a concrete client visitor <2015-07-23 Thu 11:02>
     CLOSED: [2015-08-11 Tue 07:09]
     :PROPERTIES:
     :ID:       863547ca-ce89-437e-a8a1-8d10f53d45af
     :END:
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-08-11 Tue 07:09]
     :END:
     This way we can see better how it works. It should be modelled according to
     
**** TODO what's the type for the visitors <2015-07-23 Thu 09:01>
     :PROPERTIES:
     :ID:       30ec8f0a-e2c5-4fd9-aba4-62fe586a10e5
     :END:
     It seems that for the various walk functions, we need various
     kind of visitors, how can we pass them, or do we need 
     all of them?
**** TODO checking for nil <2015-07-23 Thu 08:41>
     :PROPERTIES:
     :ID:       ae02ba3a-c73d-4766-b157-d6c6f0b4d463
     :END:
     the walk functions should be programmed defensively I assume.  In the
     go-src it's done, for the time being, I left it out from, postponed.
**** DONE add the cases for Stmt, first empty  <2015-07-23 Thu 08:47>
     CLOSED: [2015-07-23 Thu 08:50]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-23 Thu 08:50]
     :END:


**** TODO What's actuallyt the type of the Walk-function <2015-07-22 Wed 15:42>
     :PROPERTIES:
     :ID:       21d6a17a-cd9e-4948-8ad9-a7d7d5381810
     :END:


     Ok, it's not a visitor, the return type is absent (like void), so
     it's side-effect only.
***** TODO make a visitor interface for Stmt <2015-07-22 Wed 15:45>
      :PROPERTIES:
      :ID:       2e3e450d-9c05-4aae-bda7-9b82029336a5
      :END:
***** TODO make a client visitor for Stmt <2015-07-22 Wed 15:45>
      :PROPERTIES:
      :ID:       934f2372-5395-4d71-a7d1-6dc449d33f85
      :END:
***** TODO how can one make it less flat <2015-07-22 Wed 11:33>
      :PROPERTIES:
      :ID:       029ebaf0-8db4-47d1-89f1-3211e8345160
      :END:

**** TODO analyze the statements  <2015-07-13 Mon 13:55>
     :PROPERTIES:
     :ID:       1d8c8bb5-84e9-4e1e-9f17-5991a05122e8
     :END:

**** TODO where do I get the productions for Go from <2015-07-13 Mon 13:55>
     :PROPERTIES:
     :ID:       7f6953b1-d719-45b9-96d8-28aa26f79379
     :END:

**** TODO what's a production name? <2015-07-13 Mon 13:55>
     :PROPERTIES:
     :ID:       8c0c71e9-0fc2-4813-9942-480a05a40bc0
     :END:

**** DONE do go implement itself with yacc? <2015-07-13 Mon 13:56>
     CLOSED: [2015-07-13 Mon 14:05]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-13 Mon 14:05]
     :END:
     Nope, seems like not


     Many of them are also in the go-org, but while working here, 
     I add them here


*** Structure and meta things
**** DONE "test" package: how to make that a client to ast? <2015-07-16 Thu 08:01>
     CLOSED: [2015-07-16 Thu 12:04]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 12:04]
     :END:

     That's done now, in test/somename.go
** Yacc

 https://github.com/golang-samples/yacc/tree/master/simple

** Abysnt

*** FIXED somename.go does not compile now <2015-07-16 Thu 09:42>
    CLOSED: [2015-07-16 Thu 09:44]
    :LOGBOOK:
    - CLOSING NOTE [2015-07-16 Thu 09:44] \\
      SimpleExpr interface had a typo
    :END:
    The problemis SimpleExpr: the ``marker method'' has a typo
*** DONE finish the scheme uniformely <2015-07-16 Thu 09:14>
    CLOSED: [2015-07-16 Thu 09:27]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-16 Thu 09:27]
    :END:
    
    all stuff added


*** DONE make a sample program <2015-07-16 Thu 12:25>
    CLOSED: [2015-08-02 Sun 17:43]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-08-02 Sun 17:43]
    :END:
*** DONE re-add the slices again and iterate over them <2015-07-16 Thu 12:21>
    CLOSED: [2015-07-17 Fri 08:24]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-17 Fri 08:24]
    :END:
*** DONE export the print statements <2015-07-16 Thu 12:17>
    CLOSED: [2015-07-16 Thu 12:18]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-16 Thu 12:18]
    :END:
*** TODO make a ``visitor'' <2015-07-16 Thu 09:54>
    :PROPERTIES:
    :ID:       d0aab739-539d-46d1-891e-c4a7e07d02c0
    :END:

    There seem to be a kind of visitor pattern in the go-implementation
    itself. One question is why that is necessary at all. Because we have
    those external methods. Those seem to allow to do what a visitor can do
    (don't know about extensibility). Therefore: just implement one simple
    one.

    It seems to not be  immediately possible.    If I do that, it gives


      ./somename.go:28: cannot define new methods on non-local type ast.FACTOR




*** DONE non local methods: is that possible  <2015-07-16 Thu 10:16>
    CLOSED: [2015-07-16 Thu 10:31]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-16 Thu 10:31]
    :END:


     https://groups.google.com/forum/#!topic/golang-nuts/717yRSWjq5U

    ``The base type must not be a pointer or interface type and must be
     declared in the same package as the method.''

     Seems like not possible.


     In some discussion there is some mention of ``embedding''



    type MyExtension struct {
        otherPackage.Type
    }  


    func (me *MyExtension) NewMethod() { ... }



    Functions are easier
*** DONE can one make a visitor function across package boundaries <2015-07-16 Thu 12:05>
    CLOSED: [2015-08-02 Sun 17:43]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-08-02 Sun 17:43]
    :END:

*** DONE external type methods: would embedding as described be a viable solution <2015-07-16 Thu 10:31>
    CLOSED: [2015-08-02 Sun 17:43]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-08-02 Sun 17:43]
    :END:
*** TODO external type methods: compare that to the Walk-visotor in Go <2015-07-16 Thu 10:02>
    :PROPERTIES:
    :ID:       40d72ff0-36e9-4972-8f3a-a65d3aee4801
    :END:

*** DONE make a more complex client in somename <2015-07-16 Thu 09:14>
    CLOSED: [2015-07-16 Thu 09:54]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-16 Thu 09:54]
    :END:
*** TODO what constructs do normal people use for syntax trees <2015-07-13 Mon 12:02>
    :PROPERTIES:
    :ID:       09ae9fff-8ea7-4a5f-8838-3bed82ed3237
    :END:
**** TODO which does go itself use <2015-07-13 Mon 12:02>
     :PROPERTIES:
     :ID:       8d0cd17b-a072-49f1-900a-3208558046bf
     :END:
**** DONE can one check out the whole thing <2015-07-13 Mon 12:03>
     CLOSED: [2015-07-13 Mon 12:16]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-13 Mon 12:16]
     :END:

     ok, it goes with Mercury:
             hg clone https://code.google.com/p/go/

    ~/Collectionofreposes/GITHGEXTERNALS/
 
    See also now the remarks here. Also the attempts in

** Imperative visitor 
*** [[../walkimperative][Imperative walk through]]

    
*** [[../visitimperative][Imperative visiting client code]]

The directory contains all the visit-methods. For each /type/ (of the
underlying inductive definition, there is one ~Visit<Type>~-function. It is
instructive to compare their definition with the functional setting.  The
type ~visitor~ in both cases is the same (the struct). One obvious
difference is, of course, that in the functional setting the visit
functions give back an argument of type ~Visitor~ whereas here, there is no
return value. Less obvious is the type of the receiver. Here it is crucial,
that it receiver is of type ~*visitor~. Note that with both this type and
with plain type ~visitor~, the record ~visitor~ is turned into a
~Visitor~. Note that in the below definitons, one may even /mix/ the
receiver types and the compiler won't complain. That means that the
interface for ``methods'' does not distinguish between call-by-reference
and call-by-value. Note that one can recursively call in its body for
instance ~VisitStmt~ as ~v.VisitStmt(s)~ as well as ~(*v).VisitStmt(s)~
(which of course results in meaningless behavior here). Alternatively, if
one had the receiver type ~*visitor~, one could make a recursive call
~v.VisitStmt(s)~ or ~(&v).VisitStmt(s)~. That's probably because the
dot-notation is overloaded, and implicitly dereferences member access. It's
important here that the ~v~ parameter is called by reference. Otherwise,
the original value does not change.



** Functional visitor

The code here corresponds more closely to the code as found in the ast part
of the go compiler. However, it's not really functional
anyway. Furthermore, the go-compiler makes only /once/ use of such a
visitor, but there, the functional aspect is ignored, as well. The point
where it's not really functional is the various ~Walk~-functions: they do
not give back a visitor, as would be plausible if it were functional. On
the other hand, the visitor functions seem to be intended for functional
use, insofar the ~Visitor~-interface requires to return a visitor as
result, as opposed to simply changing the state of the argument visitor
(which is the receiver of the various visit functions.


***  [[../walkfunctional][Functional walk through]]
***  [[../visitfunctional][Functional visiting client code]]


* Analysis of the Go compiler (under go)
** api
** src
*** bytes
*** builtin 

*** [[~/go/src/github.com/golang/go/src/go][go]]

    What is strange here is that it looks a bit that it's more like a
    front-end. It's not clear whether it contains a back-end. Maybe the
    build.
    
**** ast
     See   [[~/go/src/github.com/golang/go/src/go/ast]]



**** build

     That's also a package. According to the documentation, it's not really
     about go build, it's about collecting info about go packages. So that
     may still be for the front end.
**** [[~/go/src/github.com/golang/go/src/go/constant][constant]]

     A small package, for ``built-in'' constants or something
     
**** [[~/go/src/github.com/golang/go/src/go/doc][doc]]
**** format
**** importer
**** internal
**** printer
**** scanner
**** token 
****   [[~/go/src/github.com/golang/go/src/go/types][types]]

   I would guess, the ~types~ package is a client of the ast.  
***** TODO who uses the types functions, which is the main one <2015-08-08 Sat 08:47>
      :PROPERTIES:
      :ID:       5a573e7c-dca2-4a80-bc89-bb35e59c1c53
      :END:
    There's a function ~Check~ but it seems mainly used only inside the
    types packages, not outside. So, that's strange. I looked only in the
    directory go/src/go. There's also more, though, for instance
     cmd/vet/main.go:347:	asmCheck(pkg)
    that gives the command go vet
***** TODO what's the result of the type checker? <2015-08-08 Sat 08:49>
      :PROPERTIES:
      :ID:       4dd10cb5-4483-465e-8a18-9a369f683d22
      :END:


*** cmd
****  [[~/go/src/github.com/golang/go/src/cmd/compile][compile]]
     That is a small package, at least the file main.go is small. It's 
     basically only a switch according to the architectures (arm etc). It's interesting
     perhaps insofar in that one can see perhaps a main functions, like ~x86.Main()~.

***** TODO What's the difference between go build and go compile? What's go compile? <2015-08-08 Sat 09:05>
      :PROPERTIES:
      :ID:       0d5d00a9-f6a9-4856-b6ab-45b434dd300e
      :END:

      Strange, go compile does not exists, despite the fact that it's a ~cmd~.


* extra stuff under [[~/go/src/golang.org/x][x]]
** Tools
*** [[~/go/src/golang.org/x/tools/go][Go]]
**** [[~/go/src/golang.org/x/tools/go/ssa][SSA]]


***** ssa.go
      This seems basically a data structure.

****** TODO how does that embedding with register works <2015-08-10 Mon 12:01>
****** DONE check the various types and their access functions <2015-08-08 Sat 14:47>
       CLOSED: [2015-08-09 Sun 11:08]
       :PROPERTIES:
       :ID:       ce717af7-031c-43b0-a14c-e137464f7284
       :END:
       :LOGBOOK:
       - State "DONE"       from "TODO"       [2015-08-09 Sun 11:08]
       :END:

       Node: String Pos Parent [Operands] [Referrers]

       To get an overview over the inteface
       

        |                    | aninstr | reg | Name | Str | Pos | Par | Ops | Refs | Block | SBlock | Type | Val | Common | Descr | sig | staticallee | isinvoke | Object | Token | Pack | Rstr   | stype   | snum   | spos   | Func | Var |       |
        |--------------------+---------+-----+------+-----+-----+-----+-----+------+-------+--------+------+-----+--------+-------+-----+-------------+----------+--------+-------+------+--------+---------+--------+--------+------+-----+-------|
        | I: Node            |         |     |      | str | pos | par | [x] | [x]  |       |        |      |     |        |       |     |             |          |        |       |      |        |         |        |        |      |     |       |
        | I: Instruction     |         |     |      | str | pos | par | ops |      | block | sblock |      |     |        |       |     |             |          |        |       |      |        |         |        |        |      |     |       |
        | I: C-Instr (Instr) |         |     |      |     |     |     |     |      |       |        |      | val | common |       |     |             |          |        |       |      |        |         |        |        |      |     |       |
        | I: Value           |         |     | name | str | pos | par |     | refs |       |        | type |     |        |       |     |             |          |        |       |      |        |         |        |        |      |     |       |
        | I:  Member         |         |     | name | str | pos |     |     |      |       |        | type |     |        |       |     |             |          | object | token | pack | rstr   |         |        |        |      |     |       |
        |--------------------+---------+-----+------+-----+-----+-----+-----+------+-------+--------+------+-----+--------+-------+-----+-------------+----------+--------+-------+------+--------+---------+--------+--------+------+-----+-------|
        | Program            |         |     |      |     |     |     |     |      |       |        |      |     |        |       |     |             |          |        |       |      |        |         |        |        |      |     |       |
        | Package            |         |     |      |     |     |     |     |      |       |        | type |     |        |       |     |             |          |        |       |      |        |         |        |        | func | var | const |
        | Type               |         |     | Name | str | Pos |     |     |      |       |        | type |     |        |       |     |             |          | object | token | pack | rstr   |         |        |        |      |     |       |
        | NamedConst         |         |     | name | str | pos |     |     |      |       |        | type |     |        |       |     |             |          | object | token | pack | rstr   |         |        |        |      |     |       |
        |--------------------+---------+-----+------+-----+-----+-----+-----+------+-------+--------+------+-----+--------+-------+-----+-------------+----------+--------+-------+------+--------+---------+--------+--------+------+-----+-------|
        | FreeVar            |         |     | name |     | pos | par | ops | refs |       |        | type |     |        |       |     |             |          |        |       |      |        |         |        |        |      |     |       |
        | Parameter          |         |     | name |     | pos | par | ops | refs |       |        | type |     |        |       |     |             |          | object |       |      |        |         |        |        |      |     |       |
        | Global             |         |     | name | str | pos | par | ops | refs |       |        | type |     |        |       |     |             |          | object | token | pack | relstr |         |        |        |      |     |       |
        | Builtin            |         |     | name |     | pos | par | ops | refs |       |        | type |     |        |       |     |             |          | object |       |      |        |         |        |        |      |     |       |
        | Const              |         |     |      |     |     |     | ops |      |       |        |      |     |        |       |     |             |          |        |       |      |        |         |        |        |      |     |       |
        | Function           |         |     | name | str | pos | par | ops | refs |       |        | type |     |        |       |     |             |          | object | token | pack |        |         |        |        |      |     |       |
        | BasicBlock         |         |     |      |     |     |     |     |      |       |        |      |     |        |       |     |             |          |        |       |      |        |         |        |        |      |     |       |
        | Alloc              |         | reg |      |     | pos |     | ops | refs |       |        | type |     |        |       |     |             |          |        |       |      |        |         |        |        |      |     |       |
        | Phi                |         | reg |      |     |     |     | ops |      |       |        |      |     |        |       |     |             |          |        |       |      |        |         |        |        |      |     |       |
        | Call               |         | reg |      |     | pos |     | ops |      |       |        |      | val | common |       |     |             |          |        |       |      |        |         |        |        |      |     |       |
        | BinOp              |         | reg |      |     |     |     | ops |      |       |        |      |     |        |       |     |             |          |        |       |      |        |         |        |        |      |     |       |
        | UnOp               |         | reg |      |     |     |     | ops |      |       |        |      |     |        |       |     |             |          |        |       |      |        |         |        |        |      |     |       |
        | ChangeType         |         | reg |      |     |     |     | ops |      |       |        |      |     |        |       |     |             |          |        |       |      |        |         |        |        |      |     |       |
        | Convert            |         | reg |      |     |     |     | ops |      |       |        |      |     |        |       |     |             |          |        |       |      |        |         |        |        |      |     |       |
        | ChangeInterface    |         | reg |      |     |     |     | ops |      |       |        |      |     |        |       |     |             |          |        |       |      |        |         |        |        |      |     |       |
        | MakeInterface      |         | reg |      |     |     |     | ops |      |       |        |      |     |        |       |     |             |          |        |       |      |        |         |        |        |      |     |       |
        | MakeClosure        |         | reg |      |     |     |     | ops |      |       |        |      |     |        |       |     |             |          |        |       |      |        |         |        |        |      |     |       |
        | MakeMap            |         | reg |      |     |     |     | ops |      |       |        |      |     |        |       |     |             |          |        |       |      |        |         |        |        |      |     |       |
        | MakeChan           |         | reg |      |     |     |     | ops |      |       |        |      |     |        |       |     |             |          |        |       |      |        |         |        |        |      |     |       |
        | MakeSlice          |         | reg |      |     |     |     | ops |      |       |        |      |     |        |       |     |             |          |        |       |      |        |         |        |        |      |     |       |
        | Slice              |         | reg |      |     |     |     | ops |      |       |        |      |     |        |       |     |             |          |        |       |      |        |         |        |        |      |     |       |
        | FieldAddr          |         | reg |      |     |     |     | ops |      |       |        |      |     |        |       |     |             |          |        |       |      |        |         |        |        |      |     |       |
        | Field              |         | reg |      |     |     |     | ops |      |       |        |      |     |        |       |     |             |          |        |       |      |        |         |        |        |      |     |       |
        | IndexAddr          |         | reg |      |     |     |     | ops |      |       |        |      |     |        |       |     |             |          |        |       |      |        |         |        |        |      |     |       |
        | Index              |         | reg |      |     |     |     | ops |      |       |        |      |     |        |       |     |             |          |        |       |      |        |         |        |        |      |     |       |
        | Lookup             |         | reg |      |     |     |     | ops |      |       |        |      |     |        |       |     |             |          |        |       |      |        |         |        |        |      |     |       |
        | SelectState        |         | [?] |      |     |     |     |     |      |       |        |      |     |        |       |     |             |          |        |       |      |        |         |        |        |      |     |       |
        | Select             |         | reg |      |     |     |     | ops |      |       |        |      |     |        |       |     |             |          |        |       |      |        |         |        |        |      |     |       |
        | Range              |         | reg |      |     |     |     | ops |      |       |        |      |     |        |       |     |             |          |        |       |      |        |         |        |        |      |     |       |
        | Next               |         | reg |      |     |     |     | ops |      |       |        |      |     |        |       |     |             |          |        |       |      |        |         |        |        |      |     |       |
        | TypeAssert         |         | reg |      |     |     |     | ops |      |       |        |      |     |        |       |     |             |          |        |       |      |        |         |        |        |      |     |       |
        | Extract            |         | reg |      |     |     |     | ops |      |       |        |      |     |        |       |     |             |          |        |       |      |        |         |        |        |      |     |       |
        | Jump               | aninstr |     |      |     | pos |     | ops |      |       |        |      |     |        |       |     |             |          |        |       |      |        |         |        |        |      |     |       |
        | If                 | aninstr |     |      |     | pos |     | ops |      |       |        |      |     |        |       |     |             |          |        |       |      |        |         |        |        |      |     |       |
        | Return             | aninstr |     |      |     | pos |     | ops |      |       |        |      |     |        |       |     |             |          |        |       |      |        |         |        |        |      |     |       |
        | RunDefers          | aninstr |     |      |     | pos |     | ops |      |       |        |      |     |        |       |     |             |          |        |       |      |        |         |        |        |      |     |       |
        | Panic              | aninstr |     |      |     | pos |     | ops |      |       |        |      |     |        |       |     |             |          |        |       |      |        |         |        |        |      |     |       |
        | Go                 | aninstr |     |      |     | pos |     | ops |      |       |        |      | val | common |       |     |             |          |        |       |      |        |         |        |        |      |     |       |
        | Defer              | aninstr |     |      |     | pos |     | ops |      |       |        |      | val | common |       |     |             |          |        |       |      |        |         |        |        |      |     |       |
        | Send               | aninstr |     |      |     | pos |     | ops |      |       |        |      |     |        |       |     |             |          |        |       |      |        |         |        |        |      |     |       |
        | Store              | aninstr |     |      |     | pos |     | ops |      |       |        |      |     |        |       |     |             |          |        |       |      |        |         |        |        |      |     |       |
        | MapUpdate          | aninstr |     |      |     | pos |     | ops |      |       |        |      |     |        |       |     |             |          |        |       |      |        |         |        |        |      |     |       |
        | DebugRef           | aninstr |     |      |     | pos |     | ops |      |       |        |      |     |        |       |     |             |          |        |       |      |        |         |        |        |      |     |       |
        |--------------------+---------+-----+------+-----+-----+-----+-----+------+-------+--------+------+-----+--------+-------+-----+-------------+----------+--------+-------+------+--------+---------+--------+--------+------+-----+-------|
        | register           | aninstr |     | name |     | pos |     |     | refs |       |        | type |     |        |       |     |             |          |        |       |      |        | settype | setnum | setpos |      |     |       |
        | anInstruction      |         |     |      |     |     | par |     | refs | block | sblock |      |     |        |       |     |             |          |        |       |      |        |         |        |        |      |     |       |
        |--------------------+---------+-----+------+-----+-----+-----+-----+------+-------+--------+------+-----+--------+-------+-----+-------------+----------+--------+-------+------+--------+---------+--------+--------+------+-----+-------|
        | CallCommon         |         |     |      |     | pos |     | op  |      |       |        |      |     | x      | descr | sig | statcallee  | isinvoke |        |       |      |        |         |        |        |      |     |       |


  
****** DONE what are the different modes for SSA (for build?)? <2015-08-09 Sun 12:28>
       CLOSED: [2015-08-09 Sun 13:47]
       :LOGBOOK:
       - State "DONE"       from "TODO"       [2015-08-09 Sun 13:47]
       :END:
       it's on mode.go

The value is a sequence of zero or more of these letters:
C	perform sanity [C]hecking of the SSA form.
D	include [D]ebug info for every function.
P	print [P]ackage inventory.
F	print [F]unction SSA code.
S	log [S]ource locations as SSA builder progresses.
L	build distinct packages seria[L]ly instead of in parallel.
N	build [N]aive SSA form: don't replace local loads/stores with registers.
I	build bare [I]nit functions: no init guards or calls to dependent inits.

****** DONE add dummy_types for program <2015-08-09 Sun 12:08>
       CLOSED: [2015-08-09 Sun 13:57]
       :LOGBOOK:
       - State "DONE"       from "TODO"       [2015-08-09 Sun 13:57]
       :END:

****** TODO Clarify the duck typing for instructions and values <2015-08-08 Sat 13:47>
       :PROPERTIES:
       :ID:       e9040670-bc7f-4cc2-a36b-3b8104bd326d
       :END:

       They share some functions, but they also have separate, it's not a
       subtype. Also Nodes it not a supertype. However, for the nodes, it
       seems intended that the node is conceptually a supertype of
       instructions and values.  The two methods Operands and Referrers,
       which are not common, but specific for values or instructions, are
       called ``partial methods''.  It's a but unclear, they say: ``Node is
       provided to simplify SSA graph algorithms.  Clients should use the
       more specific and informative Value or Instruction interfaces where
       appropriate.''


****** TODO how can one build the ``embedding/subtyping'' structure <2015-08-08 Sat 15:46>
       :PROPERTIES:
       :ID:       ac1d2103-d1e0-44d0-8fd5-d23bb80a01f1
       :END:
       in the sso.go data structures it's used for extending Instruction to CallInstructions.

       Every call instruction therefore is an instuction. How would one do it inductively?
       Let's not 

******* TODO can one ``reuse constructors'' <2015-08-08 Sat 15:58>
	:PROPERTIES:
	:ID:       feb37d79-425e-43d9-8066-3f464140fbd8
	:END:
	actually, it seems yes, but that's strange. The compiler does not
	give an error.  I would have betted it's impossible. The following
	example, the two types are ok, but it seems that the latest one
	wins. I.e., the value is wrong because of the type.

#+begin_example
type valuex = 
  | Builtin of int
  | FreeVar of unit
  | Const of unit 
  | Function of unit 
  | Global of unit 
  | Parameter of unit 

type value = 
  | Builtin of int
  | FreeVar of unit
  | Const of unit 
  | Function of unit 
  | Global of unit 
  | Parameter of unit 

let x : valuex = Const ();;

#+end_example

That would mean it's not too good, and in particular I have not achived
that value and valuex are substypes or something. Of course, one can also
not make some embedding. I guess the basic way is to ``embed'' it with
another constructor. That's not automatic or implicit, but explicit is fine
as well.  So, let's do it like that. 
 

***** create.go
****** TODO try to figure out the interface of that one <2015-08-08 Sat 13:05>
       :PROPERTIES:
       :ID:       d6927ee9-96b9-4ea6-8ffd-43e66e4b5044
       :END:
****** DONE what's a Package, and where defined <2015-08-08 Sat 13:14>
       CLOSED: [2015-08-08 Sat 13:27]
       :PROPERTIES:
       :ID:       d3551a01-8a59-4c3d-a505-67c3909ce3e5
       :END:
       :LOGBOOK:
       - State "DONE"       from "TODO"       [2015-08-08 Sat 13:27]
       :END:
       it's actually in ssa.go
***** builder.go
****** TODO try to figure out the interface of that one <2015-08-08 Sat 13:04>
       :PROPERTIES:
       :ID:       a36726a4-20d9-497a-97d4-fa1e377e9c2d
       :END:
***** General questions
     It seems that it they implement standard stuff from the literature
     (cytron*:efficiently). There are two different phases (at least),
     creating and building. First is the create, afterwards build, it
     seems. 


****** TODO what's the lifting pass in a SSA thing <2015-08-08 Sat 12:04>
       :PROPERTIES:
       :ID:       9f04ad37-89b8-44af-81c5-946241bed06d
       :END:
      Perhaps it's related to lambda-lifting.

****** DONE move the ssa on the laptop to the right place <2015-08-07 Fri 07:44>
    CLOSED: [2015-08-07 Fri 08:13]
    :PROPERTIES:
    :ID:       3b582dfe-7bfd-4b54-a5a3-26161a5ebe6e
    :END:
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-08-07 Fri 08:13]
    :END:
     ~/go/src/golang.org/x/tools/go:

     Ok, it's moved
****** TODO Who generates the SSA <2015-08-07 Fri 07:52>
       :PROPERTIES:
       :ID:       738caab9-36a2-426a-8e1e-6efbb178c835
       :END:
****** TODO where is the SSa data structure <2015-08-07 Fri 07:52>
       :PROPERTIES:
       :ID:       fe720f3a-af1c-4e17-ba10-9811d8e88f06
       :END:
****** TODO what's the Operands function <2015-08-07 Fri 07:56>
       :PROPERTIES:
       :ID:       d0afc06c-127b-4445-b95e-526a577a31f5
       :END:
****** TODO what's a Value <2015-08-07 Fri 07:57>
       :PROPERTIES:
       :ID:       784a2435-9215-449c-a999-f0d288306d16
       :END:
    A value seems to be related to instructions
****** TODO What's an ~Instruction~ Interface <2015-08-07 Fri 08:01>
       :PROPERTIES:
       :ID:       51ddf392-eedc-48ab-8bcf-5428f27cb9f3
       :END:
***** TODO ~BinOp~ why not an instruction <2015-08-07 Fri 08:15>
      :PROPERTIES:
      :ID:       50524935-e8e2-44db-afe8-6f0c1c7a245c
      :END:
     As an example they say that binary ops are instructions, but 
     how do I see that in the code?
     
     ~BinOp~ is a struct later (p 8).

     There's then the function ~Operands~ on the ~BinOp~

***** TODO is ~BinOp~ an ``instance'' of an Instraction <2015-08-07 Fri 08:40>
      :PROPERTIES:
      :ID:       f2dc8d80-8d67-4159-bc48-0b09fe8c8679
      :END:


      
* Misc


** Tmp goreconstruction


*** TODO analyze the check a bit <2015-08-15 Sat 07:04>
*** DONE add check <2015-08-15 Sat 06:48>
    CLOSED: [2015-08-15 Sat 07:04]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-08-15 Sat 07:04]
    :END:
*** DONE what about create.go and builder.go <2015-08-11 Tue 08:42>
    CLOSED: [2015-08-15 Sat 06:47]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-08-15 Sat 06:47]
    :END:
    2 phases, where create is first, I guess. bilder is much more complex.

*** TODO make a stub interface for create <2015-08-11 Tue 08:43>
    This one is relatively more easy 
*** TODO get the structure of type.type <2015-08-11 Tue 08:26>
*** DONE types_chandir <2015-08-11 Tue 07:22>
    CLOSED: [2015-08-11 Tue 07:28]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-08-11 Tue 07:28]
    :END:
    that's in type.go
*** DONE types_info <2015-08-11 Tue 07:22>
    CLOSED: [2015-08-11 Tue 07:35]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-08-11 Tue 07:35]
    :END:
*** DONE add Object <2015-08-11 Tue 07:42>
    CLOSED: [2015-08-11 Tue 07:48]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-08-11 Tue 07:48]
    :END:
    already there, just extended
*** DONE types_typename <2015-08-11 Tue 07:22>
    CLOSED: [2015-08-11 Tue 07:48]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-08-11 Tue 07:48]
    :END:
**** DONE where is that <2015-08-11 Tue 07:37>
     CLOSED: [2015-08-11 Tue 07:38]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-08-11 Tue 07:38]
     :END:
     It's called typename 
*** DONE types_const <2015-08-11 Tue 07:22>
    CLOSED: [2015-08-11 Tue 07:51]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-08-11 Tue 07:51]
    :END:
*** DONE types_object <2015-08-11 Tue 07:22>
    CLOSED: [2015-08-11 Tue 08:13]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-08-11 Tue 08:13]
    :END:

    It's an interface 
*** DONE types_selection <2015-08-11 Tue 07:22>
    CLOSED: [2015-08-11 Tue 08:17]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-08-11 Tue 08:17]
    :END:
*** DONE types_signature <2015-08-11 Tue 07:23>
    CLOSED: [2015-08-11 Tue 08:24]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-08-11 Tue 08:24]
    :END:
    it's in type.go

*** DONE types_type <2015-08-11 Tue 07:23>
    CLOSED: [2015-08-11 Tue 08:29]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-08-11 Tue 08:29]
    :END:
    type is an interface
    
*** DONE remove the extra extraflat.ml <2015-08-11 Tue 07:21>
    CLOSED: [2015-08-11 Tue 07:21]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-08-11 Tue 07:21]
    :END:
*** DONE make compilable on the computer <2015-08-11 Tue 07:14>
    CLOSED: [2015-08-11 Tue 07:16]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-08-11 Tue 07:16]
    :END:
*** DONE fill in the interface of create.ml as stub <2015-08-11 Tue 09:39>
    CLOSED: [2015-08-11 Tue 10:04]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-08-11 Tue 10:04]
    :END:
*** DONE in create: which "package" in the function  createpackage <2015-08-11 Tue 09:06>
    CLOSED: [2015-08-11 Tue 09:37]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-08-11 Tue 09:37]
    :END:
    The argument is typesPackage, the result is just Package

** Create go
*** TODO where do I find stuff like prog.canon <2015-08-13 Thu 08:07>

    It's indeed part of the type SSa.program, it's just not set in create.go
*** TODO what's canonization, is it related to type canonization <2015-08-13 Thu 08:09>
    In appel, there are canonical trees as intermediate
    representation. It's unclear if it's related as now.

    It's perhaps in typeutil. There's also canonilization for the packages

*** DONE make it compile again <2015-08-13 Thu 08:40>
    CLOSED: [2015-08-13 Thu 08:44]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-08-13 Thu 08:44]
    :END:
** Typeutil.go 
** Builder.go    
*** TODO what's the pattern types.Typ[types.Bool] <2015-08-13 Thu 11:19>
    x/go/tools/go/types is the source
    Theres types.Type, which is an interface, but we need Typ
    There's unverse.Typ

    It seems like related to a map,

    var Typ = []*Basic{
	Invalid: {Invalid, 0, "invalid type"},

	Bool:          {Bool, IsBoolean, "bool"},
	Int:           {Int, IsInteger, "int"},

    It seems like this: in type.go, they define "types" but these are just 


    
** universe.go
*** DONE what's the | in structs <2015-08-13 Thu 11:37>
    CLOSED: [2015-08-13 Thu 11:37]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-08-13 Thu 11:37]
    :END:
    seems like anonymous fields. No, it's not,

    It's and add-op. It's probably that the isBooleans etc. are seem as
    bits, basically it means it's ``both'' unsiged and integers. It's a
    bitwise or.

    
*** TODO what are anonymous fields <2015-08-13 Thu 11:38>
    It's where a field is defined implictly (only type)

