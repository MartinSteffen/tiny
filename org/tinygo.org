
* Go

  http://noypi-linux.blogspot.no/2014/07/golang-parser-generator-ebnfyacclex.html

  https://github.com/blynn/nex


  https://github.com/cznic/golex

  
** Misc (later more structure)





*** TODO Analyze the visitor in the go compiler <2015-07-17 Fri 13:16>

The visitor is contained in the ast-package (in the ast-directory). The
code is mainly defined in walk.go.  But it's used in a different
package. It's not clear if that is officially a visitor. One ingredient
seems missing, at least if one compares it to the visitor pattern as known,
namely there is no accept method: typically, the data structure being
visited has such a method, but the ast here does not. It could however be
that one may use the word ``visitor'' more loosely, as any form of
higher-order function that allows to iterate here through an inductively
defined data structure, here the ast, any form of ``fold'' function.

#+begin_example

type Visitor interface {
	Visit (stmt Node) (w Visitor)   
}
     
#+end_example

The Node is the catch-all type for all nodes of the ast (i.e., it is
embedded into all the more concrete nodes). A difference to the visitor
discussed next is that 


 What's strange he is also how it is later used, namely in the following
form (at the beginning of the Walk, function):


#+begin_example

func Walk(v Visitor, node Node) {
	if v = v.Visit(node); v == nil {
		return
	}

        ...

#+end_example


See also the ``client'' code. There are two things to do: define the
visitor, and then using it, by passing it to the Walk function. In order to
be a visitor, it must satisfy the Visitor interface. The only thing
required there is to implement the accept method (here Visit). So it's the
combination of both the data type plus the Visit-method that makes it to a
visitor.


#+begin_example

type visitor chan *ast.Ident   

func (v visitor) Visit(n ast.Node) (w ast.Visitor) {
	if ident, ok := n.(*ast.Ident); ok {  // ``special assignment'' for type assertion, ok is a boolean
		v <- ident  // send to channel v
	}
	return v
}


#+end_example


Note that the visitor is not even a struct, it's a channel (but I don't
know what all is allowed). But indeed, it's some reference type that
supports the Visit function. Also the receiver type, the argument type and
the return type are as requested by the Visitor interface. This
``function'' (represented by the visitor-references is of type

  Visitor .-> Node -> Visitor


The syntax of the if-statement is not too transparent. the "<-" syntax can
mean send or receive. But since on the left hand side there's a channel,
it's send.  Now, ast.Ident is just one kind of node, and n.(*ast.Ident) is
a type assertion. However, it's a ``special'' one because it's used in a
special kind of assignment. In this case, not panic occurs.


#+begin_example

func idents(f *ast.File) <-chan *ast.Ident {
	v := make(visitor)   // due to the above method, this results in a Visitor
	go func() {
		ast.Walk(v, f)    
		close(v)
	}()
	return v
}

#+end_example     


- First the interface: The "interface { ... }" is an interface type, the
  whole thing is a type declaration.  Inside the braces it the method
  specification. [It's a bit unclear why we can leave out ";" but ok]. The
  next one is the method name Accept, and  the signature    

                (stmt Stmt) (w Visitor)  

  https://golang.org/ref/spec#Signature

  This one is more stricky. The signature is of one of two forms:
  Parameters or Parameters Results. The signatures are described in
  connection with function types (there are examples). Even if not really
  explaned, the Visitor is the return type.
  

  






*** TODO Analyze the ``Car'' visitor <2015-07-17 Fri 15:07>

The following is an analysis of the code found at
https://gist.github.com/f0624e7760aacdc96b42.git. The structure is a bit
different, in particular the data structure being visited (see for instance
the interface ~CarPart~ below) supports an accept-function (which is
``standard''). One distiguishes best between the code for the data
structures (including the infrastructure to support ``visitors'') and the
client code, that makes use of the stuff, i.e., that provides a /concrete/
data structure, a /concrete/ visitor (and let it run).

**** Data structures

Let's start with the data structure itself, the car parts: 

#+begin_example
type CarPart interface {   
    Accept(CarPartVisitor) 
}
#+end_example


The data structure is /abstract/, just an interface. Crucial is the
presence of an accept-method, that accepts the corresponding visitor, with
the following  interface ~CarPartVisitor~:


#+begin_example
type CarPartVisitor interface {
    visitWheel(wheel *Wheel)
    visitEngine(engine *Engine)
}
#+end_example


The correspondent type in the ast of before is the ~Visitor~
interface. There are a number of differences, though. First, the
~CarPartVisitor~ interface requires /two/ visit-functions.  The intention
is (indicated also by its name) that the ~CarPartVisitor~ is used to
``visit'' car parts. However, car parts is only an interface, as well,
i.e., it's abstract. Therefore, what is /concretely/ to be visited are
instances of the ``sub-classes'' of ~CarPart~. Of course, there's no
subclassing here. What matters is elements that match the ~CarPart~
interface:

So, that is the classic visitor structure: The data structure supports an
accept function which takes the visitor as argument, and in term the
visitor has a visit-function, which takes data-structures as argument,
i.e., here ~CarPart~'s. Being abstract, the visit-function is /split/ into
two cases, handling concrete car parts. Perhaps that is a (small) price to
pay for the absence of /method overloading/ that we one has to choose two
differnent names for the two visit-functions. With this kind of
overloading, one might have gotten away with just calling both just ~visit~.

Now, as mentioned, with duck typing (and the ~CarPart~-interface given as
is) car parts are /defined/ as those elements which accept a car-part
visitor!  That would some stucts, namely cars, engines, and wheels

#+begin_example
//------------------------- car part: wheel ---------
 type Wheel struct {
    Name string
}
 
func (this *Wheel) Accept(visitor CarPartVisitor) {
    visitor.visitWheel(this)   ``function application'' via call-back
}

//------------------------- car part: engine ---------

type Engine struct {}
 
func (this *Engine) Accept(visitor CarPartVisitor) {
    visitor.visitEngine(this)   // ``function application'' via call-back
}
 
//------------------------- car part: car ---------
type Car struct {
    parts []CarPart
}
 
func NewCar() *Car {
    this := new(Car)
    this.parts = []CarPart{
        &Wheel{"front left"},
        &Wheel{"front right"},
        &Wheel{"rear right"},
        &Wheel{"rear left"},
        &Engine{}}
    return this
}
 
func (this *Car) Accept(visitor CarPartVisitor) {
    for _, part := range this.parts {
        part.Accept(visitor)
    }
}
 
#+end_example

Note that, as requested by the car part interface, the car parts must
support the ~Accept~ method. That means, the data structures themselves
must be ``changed'' to support the visitor pattern. In go, the method can
be externally ``attached'' to the data structure, but due to scope
restriction, one cannot add those methods from outside a given package
(maybe not even outside a file).


A side remark on the design: as mentioned above, the ~CarPartVisitor~
support visit functions for two concrete car parts, namely wheels and
engines, and they are called differently. I think a different design would
be possible two, using only one single ~visit~-function, with then the
/abstract/ ~CarPart~ as type of the parameter, not the concrete struct
types. If doing so, the ``dispatch'' to the different cases needs to by one
inside (i.e., at the start) of the body of that method. That would be done
/switching/ on the different options (with the help of the special form of
/type assertions/, like ~y := cp.(type)~). It would be a way of achieving
the same --dispatch on the type argument-- as with method overloading
(which we don't have in go) except that we'd actually had only one
~visit~-method.

Note finally: there are /three/ concrete types (i.e., record types) which
are car parts (namely those which support the accept method), wheels,
engines, but also cars themselves. However, the visitor ~CarPartVisitor~
covers only the wheels and the engine. The reason is: one ~Car~ already has
a kind of ``visitor'' functionality in the following sense: the car
basically a ``list'' of car-parts (as a slice). For slices, there is
already an official iteration pattern, the for-loop in connection with the
range-construct. So, this part of the data structure is ``iterated over''
not with the ``visit/accept'' pattern. Besides that: it is not really clean
design that cars are also car part (no just because in ``real life'' it
sounds strange). In an inductive definition or in a functional language,
the type of cars would not be ``merged'' with that of its parts.

**** Client code

So far everything was abstact, we have some infrastructure to run a
``fold''.  So we need to declare / define a concrete struct implementing
the visitor (the struct is declared, but the methods, attached to it, are
defined).


#+begin_example
type GetMessageVisitor struct{
    Messages []string
}
 
func (this *GetMessageVisitor) visitWheel(wheel *Wheel) {
    this.Messages = append(this.Messages, fmt.Sprintf("Visiting the %v wheel\n", wheel.Name))
}
 
func (this *GetMessageVisitor) visitEngine(engine *Engine) {
    this.Messages = append(this.Messages, fmt.Sprintf("Visiting engine\n"))
}

#+end_example


#+begin_example
func main() {
    car := NewCar()
    visitor := new(GetMessageVisitor)
    car.Accept(visitor)
    fmt.Println(visitor.Messages)
}

#+end_example

**** An equivalent functional data structure

The above structure is rather clumsy when compared to functional
representation with higher-order functions and pattern matching. The
example is also slightly too simple. The visitors are used in particular
also to iterate through a /recursive/ or /inductively given/ data
structures. The parts of a car here are not recursive. The only recursive
part is the fact that cars have a field implemented as slice (of car
parts). In connection with that: the fact that cars are also car parts
would allow that cars could contains cars as parts, which would add an
element of recursive definition here. But that's not intended,
pragmatically at least. So the only recursive part here, which is the
slice, is not actually solved following the accept/visit-structure of the
visitor pattern. Instead, the slice is iterated over using the for-loop in
connection with the range-construct. Anyhow, the data type in a
functional/inductive representation looks as follows, where I use list as
replacement for the slice in go:

#+begin_example
   type carpart = 
     | Engine of unit 
     | Wheel of string


   type car = carpart list  
#+end_example

Unlike the representation in the go code, ~car~ here is not at the same
time a ~carpart~. If one wanted a 100% correspondence, one had to make the
two type definition mutually recursive, but it is clearly not what the
example is intended to model.

**** DONE Why is there no ~visit~-function for cars? <2015-07-17 Fri 19:57>
     CLOSED: [2015-07-18 Sat 11:15]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-18 Sat 11:15]
     :END:

As explained, there are three concrete car parts, but car part visitor has
only 2 two methods, i.e., it can only react to two of them (engines and
wheels, but not cars). It's because the car (which is strangely also a car
part), is nothing else than a ``list'' in the form of a slice. A visitor is
supposed to iterate through that thing. But 1) a slice is not a car part
insofar it does not support an ``accept'' method (but cars
do). Furthermore, 2) there is an official way to iterate through a slice,
that's the for-loop in connection with the range-construct. That's what's
done here.



*** TODO duck typing  ``marker'' functions: accept <2015-07-18 Sat 13:45>

    Currently the subtyping is done by some marker functions. Now that
    we have the accept functions: do the make the older name based markers
    superfluous?

    Currently we leave them in, we experiment with it later 
*** TODO add the argument to the accept functions for statements <2015-07-18 Sat 14:13>
*** DONE port it to ssh: change the url? <2015-07-17 Fri 08:47>
    CLOSED: [2015-07-17 Fri 08:50]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-17 Fri 08:50]
    :END:


    git remote -v 

    Currently origin	https://github.com/MartinSteffen/tiny (fetch)
              origin	https://github.com/MartinSteffen/tiny (push)



    git remote set-url origin git@github.com:USERNAME/OTHERREPOSITORY.git

    Take care: there's a ":"




*** DONE add a Node to the ast.go <2015-07-17 Fri 09:12>
    CLOSED: [2015-07-17 Fri 09:18]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-17 Fri 09:18]
    :END:
*** DONE visitor: where does the Node come from <2015-07-17 Fri 09:09>
    CLOSED: [2015-07-17 Fri 09:12]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-17 Fri 09:12]
    :END:
    It's at least not in the same file, probably it's package wide
    so it's in ast.go
*** DONE make a better README.md <2015-07-16 Thu 09:54>
    CLOSED: [2015-07-17 Fri 08:24]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-17 Fri 08:24]
    :END:
     see http://stackoverflow.com/questions/8655937/github-readme-and-readme-md
*** DONE can one open a package <2015-07-16 Thu 08:11>
    CLOSED: [2015-07-17 Fri 08:25]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-17 Fri 08:25]
    :END:

    This one is not nice

	f :=    &ast.NUMBER{1}


	But it seems that it's not forseen




*** TODO just make a functional implementation, to make the types clearer <2015-07-18 Sat 09:02>
*** DONE capitalize the rest in ast <2015-07-16 Thu 09:03>
    CLOSED: [2015-07-16 Thu 09:09]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-16 Thu 09:09]
    :END:

*** FIXED why does the import in somename.org not work <2015-07-16 Thu 08:05>
    CLOSED: [2015-07-16 Thu 08:50]
    :LOGBOOK:
    - CLOSING NOTE [2015-07-16 Thu 08:50] \\
      some names were not exported
    :END:
    It's really weird. This one works

    import ("fmt"
	"ast")


   I would have thought it's

    import ("fmt"
	"github.com/MartinSteffen/tiny/ast")


   but those give the above errors 


   => It seems to related to the fact that some of the stuff is not

      exported

     After changing the type from number to int (which is the same but definitely
     global, I get the error

      ./somename.go:16: implicit assignment of unexported field 'n' in ast.NUMBER literal

      That means (I assume) that somehow NUMBER (or more probably it's fields)
      are not known outside


**** DONE how does one export stuff (types, and fields of constructors)  <2015-07-16 Thu 08:40>
     CLOSED: [2015-07-16 Thu 08:50]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 08:50]
     :END:

     It's done via capitalization. I changed the type and the constructor, then it works
**** DONE make it number instead of int again and export <2015-07-16 Thu 08:40>
     CLOSED: [2015-07-16 Thu 08:50]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 08:50]
     :END:
     -> Make it to "Number".
     -> make the field capitalized as wellx


**** DONE install ast.go <2015-07-16 Thu 08:24>
     CLOSED: [2015-07-16 Thu 08:38]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 08:38]
     :END:
     
     That might be the source of the problems now: the somename may not find
     it because the error is in ast.go, not in somename.go?

*** FIXED make somename.go compile: arguments for constructors  <2015-07-16 Thu 08:21>
    CLOSED: [2015-07-16 Thu 09:00]
    :LOGBOOK:
    - CLOSING NOTE [2015-07-16 Thu 09:00] \\
      the ast was not exported properly (and perhaps the package name of ast was
      unfitting and ast not installed.
    :END:
    
    It's weird, seems there is some inconsistencies. If I program in
    ast/ast.go , (which I currently call package go), then I can do

   func main () {
  	f :=    &NUMBER{1}
	fmt.Println(f)
	
   }
   
   inside the file ast.go. If I do that in the other package test/somename.go
   writing 

   func main () {
  	f :=    &ast.NUMBER{1}
 	fmt.Println(f)
	
   }

   then the compiler complains that he cannot figure out the arg.

   Perhaps that's because the package name etc are not yet fully clarified
   and it does not find the "ast"



   

*** DONE add to the org-path <2015-07-16 Thu 07:55>
    CLOSED: [2015-07-16 Thu 09:10]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-16 Thu 09:10]
    :END:
    ok
*** DONE make it to a worspace/package or whatever <2015-07-15 Wed 13:32>
    CLOSED: [2015-07-16 Thu 07:50]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-16 Thu 07:50]
    :END:

    See https://golang.org/doc/code.html

    it needs a workspace.

    But the workspace is just ~/go and the point where GOROOT shows

    


*** TODO can one access the stuff inside the package ast itself? <2015-07-16 Thu 10:38>

**** TODO if yes, would it help: can one make use of it? <2015-07-16 Thu 10:38>


**** DONE add print_Number <2015-07-16 Thu 14:15>
     CLOSED: [2015-07-16 Thu 14:17]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 14:17]
     :END:
**** DONE add Print_Factor <2015-07-16 Thu 14:12>
     CLOSED: [2015-07-16 Thu 14:17]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 14:17]
     :END:
**** DONE add Print_Term <2015-07-16 Thu 14:00>
     CLOSED: [2015-07-16 Thu 14:09]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 14:09]
     :END:

**** DONE add print_add_op <2015-07-16 Thu 14:00>
     CLOSED: [2015-07-16 Thu 14:32]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 14:32]
     :END:
**** DONE add Print_SimpleExpr <2015-07-16 Thu 13:36>
     CLOSED: [2015-07-16 Thu 14:00]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 14:00]
     :END:

**** FIXED Print_Term(se.T)  // error <2015-07-16 Thu 13:54>
     CLOSED: [2015-07-16 Thu 13:58]
     :LOGBOOK:
     - CLOSING NOTE [2015-07-16 Thu 13:58] \\
       ok, TERM instead of Term
     :END:

     Inside Print_SimpleExpr: bug

     perhaps duplication?
**** FIXED print_Simple_Expr leads to an compile error <2015-07-16 Thu 13:43>
     CLOSED: [2015-07-16 Thu 13:45]
     :LOGBOOK:
     - CLOSING NOTE [2015-07-16 Thu 13:45] \\
       Simply pointer type instead of struct
     :END:

**** DONE add Print_Compare_Op <2015-07-16 Thu 13:36>
     CLOSED: [2015-07-16 Thu 13:39]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 13:39]
     :END:
**** DONE add Print_Expr <2015-07-16 Thu 13:25>
     CLOSED: [2015-07-16 Thu 13:34]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 13:34]
     :END:
**** TODO make more careful name conventions <2015-07-16 Thu 14:28>
**** TODO grouping: can one group the marker methods inside the ()? <2015-07-16 Thu 14:30>
     of course it may not be worth it.
**** TODO Stmt etc.: use slices <2015-07-16 Thu 14:28>
**** DONE can one make the functions mutually recursive <2015-07-16 Thu 12:01>
     CLOSED: [2015-07-16 Thu 12:31]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 12:31]
     :END:
     yes, that seems allowed

**** DONE activate some client code <2015-07-16 Thu 12:03>
     CLOSED: [2015-07-16 Thu 14:17]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 14:17]
     :END:
**** FIXED interface receiver:  why is it not possbible to do func (Stmt) print_stmt () {..} <2015-07-16 Thu 11:25>?
     CLOSED: [2015-07-16 Thu 11:51]
     :LOGBOOK:
     - CLOSING NOTE [2015-07-16 Thu 11:51] \\
       methods don't work (the receiver cannot be abstract) but function work
     :END:
     Well, I fuess we need an argument. But that's not the only error

    Stmt: it must not be a pointer or interface type and it must be
    declared in the same package as the method. 

    so, interfaces =abstract 

***** DONE can one make a function instead of a method? <2015-07-16 Thu 11:42>
      CLOSED: [2015-07-16 Thu 11:51]
      :LOGBOOK:
      - State "DONE"       from "TODO"       [2015-07-16 Thu 11:51]
      :END:
      Ok, at least one can pass that as argument
**** TODO how did the "go" implementation walker implementation work? <2015-07-16 Thu 11:33>
      This one did not have problems.

      Yes


*** TODO external visitor via embedding or wrappers or something? <2015-07-18 Sat 12:21>
    is that possible? Currently I did not do that, just a more direct implementation

*** TODO make a visitor <2015-07-17 Fri 09:32>
*** TODO make a visit/accept visitor here <2015-07-18 Sat 11:41>
**** TODO can one make the additional infra-structure in a sep. file <2015-07-18 Sat 12:01>
     It still would not solve the problem, I assume, that one let the
    original ``package'' untouched. But at least the file. I am pretty sure
    that one cannot define it outside the package.

***** TODO try to add an Accept method to Stmt <2015-07-18 Sat 12:09>
      To figure out if I can do it in the same package but different file.

      Ok, the latter one does not work, because it _needs to be done for
      the Stmt interface. It may be possible
****** DONE Add the correct type <2015-07-18 Sat 14:51>
       CLOSED: [2015-07-18 Sat 14:54]
       :LOGBOOK:
       - State "DONE"       from "TODO"       [2015-07-18 Sat 14:54]
       :END:
****** TODO figure out the right type <2015-07-18 Sat 14:54>

       we are given

         stmt ::= IF exp ....

       so IF must accept a Stmt_Visitor.
       
       This is what we have done anyway: the IF constuctor is a statement 
       and therefore accepts a StmtVisitor. The problem starts with 
       its first component, the expression. expressions are not of
       type statement. Therefore they also don't support a visit_Exp.

       note: of course: if the first component of the IF were a stmt
       we could also not just do

         visitor.visit_stmt(this)

      we simply don't have those functions.

      Probably, we need a generic visitor 



That does not work
type Visitor interface {     // new attempt
	visit_Stmt (s Stmt)  // just a dispatch
	visit_Expr (e Expr)  // just a dispatch
}

func (s *Stmt) visit_Stmt () {}
func (s *Expr) visit_Expr () {}


****** TODO why not manke Visitor a super-interface? <2015-07-18 Sat 16:10>
       I guess that might work, the question is, does it fit with duck typing

       The problem also is: everything works fine with concrete stuff
       gluing stuff to

       IF / WhEN so visit_IF is ok, but not visit_Expr because Expr is not a struct. 
       We cannot glue anything to Exp.

****** TODO  Make a general visitor +  general dispatch <2015-07-18 Sat 15:28>      




**** DONE simplify the syntax: stmt no slice <2015-07-18 Sat 15:33>
     CLOSED: [2015-07-18 Sat 15:58]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-18 Sat 15:58]
     :END:
**** TODO do the stmt slices back in <2015-07-18 Sat 15:33>
**** DONE can one make a less flat visitor <2015-07-17 Fri 09:33>
     CLOSED: [2015-07-18 Sat 14:14]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-18 Sat 14:14]
     :END:

     The visitor of go is flat.  My recursive function was not. So, I would
     like a similar design here.

     In my file, there's a function there Print_<nonterminal> for all of
     those. Probably, there'd b a visitor for all of those =>
     
     Let's make a visitor for all Print_X.

     That would probably mean whe need a visitor interface for all the
     phrases.

     Yes, it seems easily possible

**** DONE add a visitor for staments <2015-07-17 Fri 09:59>
     CLOSED: [2015-07-18 Sat 14:14]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-18 Sat 14:14]
     :END:


     What is uncear is how to escape to the other clauses. We have to see about that
     
     Why I need is an visitor, that's done with make(visitor)




**** DONE why is an ``instance'' of visitor a Visitor <2015-07-17 Fri 14:10>
     CLOSED: [2015-07-17 Fri 14:20]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-17 Fri 14:20]
     :END:
     the ast.Walk function requests 2 args (it's a function not a method)

     The first argument is of type Visitor (not visitor), but we hand over
     an element of type visitor.

     Well, it ``glues'' a visitor function to it






**** DONE check some other visitor examples <2015-07-17 Fri 12:22>
     CLOSED: [2015-07-18 Sat 14:14]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-18 Sat 14:14]
     :END:


     https://gist.github.com/francoishill/f0624e7760aacdc96b42

     They use more standard "terminology", what's called "Visit" here is
     called "Accept" there. It's not really an inductive structure, but
     ok. They don't deal with channels.

     CarPart is abstact, so there are no instances thereof.




***** DONE which are implementations (``substypes'') of CarPart <2015-07-17 Fri 12:53>
      CLOSED: [2015-07-18 Sat 14:14]
      :LOGBOOK:
      - State "DONE"       from "TODO"       [2015-07-18 Sat 14:14]
      :END:

      We have nominal subtyping, so we need one with Accept



     

     carpart = 
     

**** TODO are the visitors the (only) way that the go books speak about higher-order programming? <2015-07-17 Fri 12:23>


**** DONE what does make <2015-07-17 Fri 11:41>
     CLOSED: [2015-07-18 Sat 14:15]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-18 Sat 14:15]
     :END:
     one cannot do make (int) for instance 
     
     for slices, maps, channels

    Unlike new, make's return type is the same as the type of its argument, 

    But if make can be done for those things only, the question is what 
    is the function-visitor? I don't think it's a slice. In the example it's
    a channel. It's not necessary connected with the thing we are after.
    IT's just one specific visitor


**** DONE what's the type ov visitor? <2015-07-17 Fri 11:48>
     CLOSED: [2015-07-17 Fri 11:49]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-17 Fri 11:49]
     :END:
     

    ok, it's a channel

      type visitor chan *ast.Ident

      
    
    
**** DONE is there also a _use_ of the concrete visitor <2015-07-17 Fri 10:36>
     CLOSED: [2015-07-17 Fri 10:39]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-17 Fri 10:39]
     :END:
     Yes, the have

#+begin_example
func idents(f *ast.File) <-chan *ast.Ident {
	v := make(visitor)
	go func() {
		ast.Walk(v, f)
		close(v)
	}()
	return v
#+end_example


**** DONE do they have an example of a concrete visitor <2015-07-17 Fri 10:18>
     CLOSED: [2015-07-17 Fri 10:22]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-17 Fri 10:22]
     :END:
     Seems like in printer/printer_test.go there is one 
**** DONE make already now a client code <2015-07-17 Fri 10:00>
     CLOSED: [2015-07-18 Sat 14:15]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-18 Sat 14:15]
     :END:
     for early testing.

**** DONE what would be the functional equivalent to a visitor, implement one <2015-07-17 Fri 09:42>
     CLOSED: [2015-07-17 Fri 09:59]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-17 Fri 09:59]
     :END:

     move to the other repos




     

**** TODO how does the walk-thing go <2015-07-14 Tue 07:57>

   See 

    ~/Collectionofreposes/GITHGEXTERNALS/go/src/go/ast/


    That's a kind of visitor. It imports the ast 

    It does not seem to do much, it just walks through it. As expected it's
    a recursive function. It takes two argument, the second one is the
    visitor. That's the ``functional'' argument.


*** DONE How to make an iterator over slices <2015-07-17 Fri 07:57>
    CLOSED: [2015-07-17 Fri 08:23]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-17 Fri 08:23]
    :END:
    See page 154: a read-only access: with range 

*** DONE can I make use of that function in the test thing? <2015-07-16 Thu 14:35>
    CLOSED: [2015-07-17 Fri 07:57]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-17 Fri 07:57]
    :END:
*** TODO make the print-out at least a bit readable <2015-07-16 Thu 14:34>
*** TODO make a running program making use of a program <2015-07-14 Tue 12:16>
**** DONE in the parser: how are the nodes created <2015-07-14 Tue 11:38>
     CLOSED: [2015-07-15 Wed 08:04]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-15 Wed 08:04]
     :END:
***** DONE look at standard cases <2015-07-14 Tue 11:51>
      CLOSED: [2015-07-14 Tue 12:16]
      :LOGBOOK:
      - State "DONE"       from "TODO"       [2015-07-14 Tue 12:16]
      :END:

      Here seems one:
-------------------------------------------------------------------------
	case token.SEMICOLON:
  		s = &ast.EmptyStmt{Semicolon: p.pos}
-------------------------------------------------------------------------
    ast is unclear where defined. It's a package, maybe that's what's ment-

    EmptyStmt in the package is 

	EmptyStmt struct {
		Semicolon token.Pos // position of preceding ";"
	}

	So, that's then the syntax to create a node, here 



***** DONE what does the make function do in go? <2015-07-14 Tue 11:39>
      CLOSED: [2015-07-15 Wed 08:04]
      :LOGBOOK:
      - State "DONE"       from "TODO"       [2015-07-15 Wed 08:04]
      :END:
      it's similar to new:  works for type slice, map, or chan (only). 
      It not needed here
***** CANCELLED new: can one have arguments <2015-07-14 Tue 11:45>
      CLOSED: [2015-07-15 Wed 08:04]
      :LOGBOOK:
      - CLOSING NOTE [2015-07-15 Wed 08:04]
      :END:
***** DONE why does new not have a sep. category in the ast <2015-07-14 Tue 11:46>
      CLOSED: [2015-07-14 Tue 11:47]
      :LOGBOOK:
      - State "DONE"       from "TODO"       [2015-07-14 Tue 11:47]
      :END:
      it's a built-in function, probably that's the reason
***** DORMANT if new is built in, how is it implemented <2015-07-14 Tue 11:47>
      CLOSED: [2015-07-15 Wed 08:04]
      :LOGBOOK:
      - CLOSING NOTE [2015-07-15 Wed 08:04]
      :END:
**** DONE is the ``inductive structure'' of the AST flat or not? <2015-07-14 Tue 08:51>
     CLOSED: [2015-07-15 Wed 08:05]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-15 Wed 08:05]
     :END:
     For the switch-construct it is. It needs not be, though
**** DONE what's the node.(type) there? <2015-07-14 Tue 08:08>
     CLOSED: [2015-07-14 Tue 08:35]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-14 Tue 08:35]
     :END:
     node: Node. The node is the top-``Ã¬nterface''

     In the ast.go, there are a few comments like

	Type   Expr      // asserted type; nil means type switch X.(type)
   so probably that is a general go language thing.


   Anyway, it's a special form (or variant) of a type assertion. It's a
   type switch. It's indeed used om a big switch-case.

**** DONE how does the case switch in walk.go works <2015-07-14 Tue 08:35>
     CLOSED: [2015-07-14 Tue 11:35]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-14 Tue 11:35]
     :END:
     
     It uses a type switch switch n := node.(type). That gives various
     cases. It seems that the case-switch structure is flat , despite the
     fact that there are substructures of Node.

***** DONE flat case switch in walk.go ? <2015-07-14 Tue 09:37>
      CLOSED: [2015-07-14 Tue 11:35]
      :LOGBOOK:
      - State "DONE"       from "TODO"       [2015-07-14 Tue 11:35]
      :END:

      Is it true that the case switch is flat? -> yes

**** DONE what's the ``type'' of n in switch n := node.(type)? <2015-07-14 Tue 08:37>
     CLOSED: [2015-07-14 Tue 09:32]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-14 Tue 09:32]
     :END:
     It seems that this is _not_ fixed. It seems that n is just the node
     which is represented by n. That can be seen in walk.go by looking at
     the different cases in the case switch. Depending on the case, one
     makes use of things like n.Doc or n.Low. For instance, in case n is of
     type *Field (i.e., a reference to a Field): the type Field is a
     struct, i.e., a struct type (or record type).  Now, fields are structs
     which have a ``field'' like Doc. In a functional language, it's like

     Field of CommentGroup *  Ident *  Expr * BasicLit * CommentGoup (1)

    If of course not a tuple but a record, but ok.

     That one is a Node. Let's ignore the sub-structures, because they
     don't play a role, probably in the switching. Anyhow: the particular
     node constructed via Field has 5 args, as given above in (1). In ms, they would be matched like

     match n with
       Field(c1,i,e.b.c2) -> 

    which means the names are given locally. In the kind of programming here it's with 
    selectors like

      n.Doc 


      depending on the type switch case, different selectors apply of course.
    

     


**** TODO  what's struct ( interfaces ) <2015-07-15 Wed 08:14>
     It's in the ast of go. We shoold also look at the book and the spec
**** TODO AST: Fields why are some of the things as pointers and some not <2015-07-14 Tue 08:58>
**** DONE Constructors: it seems that in AST, they ``mimic'' those: how to set them <2015-07-14 Tue 09:16>
     CLOSED: [2015-07-15 Wed 08:06]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-15 Wed 08:06]
     :END:
     
     One may see that for instance for Field: it's a struct type, and has a
     number of fields. That seems to me like describing the result of
     applying a constructor. The question then is how to do that?

     I guess, one may simply write some functions, or better methods.

     I'd actually expect that a parser should have some such
     functions/methods, one should check there ->
     
     yes.

     It seems like CONSTRUCTOR { file : value}
***** DONE check the parser for constructors (or ast) <2015-07-14 Tue 09:21>
      CLOSED: [2015-07-15 Wed 08:06]
      :LOGBOOK:
      - State "DONE"       from "TODO"       [2015-07-15 Wed 08:06]
      :END:
*** TODO look at how the parser works <2015-07-14 Tue 07:55>
*** TODO look at the example_test.go program <2015-07-14 Tue 07:52>
*** TODO constructors / inductive definition in go <2015-07-14 Tue 07:26>
*** DONE how can one implement the AST? <2015-07-12 Sun 18:22>
    CLOSED: [2015-07-14 Tue 07:18]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-14 Tue 07:18]
    :END:
    I check via the go ast 
*** DONE what's golex go lex, why don't I have it <2015-07-12 Sun 13:59>
    CLOSED: [2015-07-12 Sun 14:23]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-12 Sun 14:23]
    :END:

    they have go tool yacc, but no lex, but there it is.

    "https://github.com/cznic/golex"

    go get lex did it! 

** Go language questions

   See also the go.org file

*** TODO how is the AST of go designed <2015-07-13 Mon 13:05>
    
    Probably they use structural subtyping. There are 4 important
    interfaces. Probably one can illustrate it as follows:

    
                   Node
                /   |    \
	    Exp    Stmt  Decl

 
The language is probably readable at

   https://golang.org/ref/spec     


For instance for the statements

Statement =
	Declaration | LabeledStmt | SimpleStmt |
	GoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt |
	FallthroughStmt | Block | IfStmt | SwitchStmt | SelectStmt | ForStmt |
	DeferStmt .

SimpleStmt = EmptyStmt | ExpressionStmt | SendStmt | IncDecStmt | Assignment | ShortVarDecl .


That does not 100% correspond to what one sees in the implementation. I
would rather like to come up with a scheme, which is more or less schematic
_AND_ corresponds 100% to the grammar. We should have a look at 2 things,
the grammar _and_ the ML ast. I guess the better starting point is the
ast. That should very much determine the tree, because it's a tree.




**** TODO why do they even distinguish 

**** TODO analyze the statements  <2015-07-13 Mon 13:55>

**** TODO where do I get the productions for Go from <2015-07-13 Mon 13:55>

**** TODO what's a production name? <2015-07-13 Mon 13:55>

**** DONE do go implement itself with yacc? <2015-07-13 Mon 13:56>
     CLOSED: [2015-07-13 Mon 14:05]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-13 Mon 14:05]
     :END:
     Nope, seems like not


     Many of them are also in the go-org, but while working here, 
     I add them here



*** Structure and meta things
**** DONE "test" package: how to make that a client to ast? <2015-07-16 Thu 08:01>
     CLOSED: [2015-07-16 Thu 12:04]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 12:04]
     :END:

     That's done now, in test/somename.go
** Yacc

 https://github.com/golang-samples/yacc/tree/master/simple

** Abysnt

*** FIXED somename.go does not compile now <2015-07-16 Thu 09:42>
    CLOSED: [2015-07-16 Thu 09:44]
    :LOGBOOK:
    - CLOSING NOTE [2015-07-16 Thu 09:44] \\
      SimpleExpr interface had a typo
    :END:
    The problemis SimpleExpr: the ``marker method'' has a typo
*** DONE finish the scheme uniformely <2015-07-16 Thu 09:14>
    CLOSED: [2015-07-16 Thu 09:27]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-16 Thu 09:27]
    :END:
    
    all stuff added


*** TODO make a sample program <2015-07-16 Thu 12:25>
*** DONE re-add the slices again and iterate over them <2015-07-16 Thu 12:21>
    CLOSED: [2015-07-17 Fri 08:24]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-17 Fri 08:24]
    :END:
*** DONE export the print statements <2015-07-16 Thu 12:17>
    CLOSED: [2015-07-16 Thu 12:18]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-16 Thu 12:18]
    :END:
*** TODO make a ``visitor'' <2015-07-16 Thu 09:54>

    There seem to be a kind of visitor pattern in the go-implementation
    itself. One question is why that is necessary at all. Because we have
    those external methods. Those seem to allow to do what a visitor can do
    (don't know about extensibility). Therefore: just implement one simple
    one.

    It seems to not be  immediately possible.    If I do that, it gives


      ./somename.go:28: cannot define new methods on non-local type ast.FACTOR




*** DONE non local methods: is that possible  <2015-07-16 Thu 10:16>
    CLOSED: [2015-07-16 Thu 10:31]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-16 Thu 10:31]
    :END:


     https://groups.google.com/forum/#!topic/golang-nuts/717yRSWjq5U

    ``The base type must not be a pointer or interface type and must be
     declared in the same package as the method.''

     Seems like not possible.


     In some discussion there is some mention of ``embedding''



    type MyExtension struct {
        otherPackage.Type
    }  


    func (me *MyExtension) NewMethod() { ... }



    Functions are easier
*** TODO can one make a visitor function across package boundaries <2015-07-16 Thu 12:05>

*** TODO external type methods: would embedding as described be a viable solution <2015-07-16 Thu 10:31>
*** TODO external type methods: compare that to the Walk-visotor in Go <2015-07-16 Thu 10:02>

*** DONE make a more complex client in somename <2015-07-16 Thu 09:14>
    CLOSED: [2015-07-16 Thu 09:54]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-16 Thu 09:54]
    :END:
*** TODO what constructs do normal people use for syntax trees <2015-07-13 Mon 12:02>
**** TODO which does go itself use <2015-07-13 Mon 12:02>
**** DONE can one check out the whole thing <2015-07-13 Mon 12:03>
     CLOSED: [2015-07-13 Mon 12:16]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-13 Mon 12:16]
     :END:

     ok, it goes with Mercury:
             hg clone https://code.google.com/p/go/

    ~/Collectionofreposes/GITHGEXTERNALS/
 
    See also now the remarks here. Also the attempts in

