
* Go

  http://noypi-linux.blogspot.no/2014/07/golang-parser-generator-ebnfyacclex.html

  https://github.com/blynn/nex


  https://github.com/cznic/golex

  
** Misc (later more structure)




*** DONE make a better README.md <2015-07-16 Thu 09:54>
    CLOSED: [2015-07-17 Fri 08:24]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-17 Fri 08:24]
    :END:
     see http://stackoverflow.com/questions/8655937/github-readme-and-readme-md
*** DONE can one open a package <2015-07-16 Thu 08:11>
    CLOSED: [2015-07-17 Fri 08:25]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-17 Fri 08:25]
    :END:

    This one is not nice

	f :=    &ast.NUMBER{1}


	But it seems that it's not forseen




*** DONE capitalize the rest in ast <2015-07-16 Thu 09:03>
    CLOSED: [2015-07-16 Thu 09:09]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-16 Thu 09:09]
    :END:

*** FIXED why does the import in somename.org not work <2015-07-16 Thu 08:05>
    CLOSED: [2015-07-16 Thu 08:50]
    :LOGBOOK:
    - CLOSING NOTE [2015-07-16 Thu 08:50] \\
      some names were not exported
    :END:
    It's really weird. This one works

    import ("fmt"
	"ast")


   I would have thought it's

    import ("fmt"
	"github.com/MartinSteffen/tiny/ast")


   but those give the above errors 


   => It seems to related to the fact that some of the stuff is not

      exported

     After changing the type from number to int (which is the same but definitely
     global, I get the error

      ./somename.go:16: implicit assignment of unexported field 'n' in ast.NUMBER literal

      That means (I assume) that somehow NUMBER (or more probably it's fields)
      are not known outside


**** DONE how does one export stuff (types, and fields of constructors)  <2015-07-16 Thu 08:40>
     CLOSED: [2015-07-16 Thu 08:50]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 08:50]
     :END:

     It's done via capitalization. I changed the type and the constructor, then it works
**** DONE make it number instead of int again and export <2015-07-16 Thu 08:40>
     CLOSED: [2015-07-16 Thu 08:50]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 08:50]
     :END:
     -> Make it to "Number".
     -> make the field capitalized as wellx


**** DONE install ast.go <2015-07-16 Thu 08:24>
     CLOSED: [2015-07-16 Thu 08:38]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 08:38]
     :END:
     
     That might be the source of the problems now: the somename may not find
     it because the error is in ast.go, not in somename.go?

*** FIXED make somename.go compile: arguments for constructors  <2015-07-16 Thu 08:21>
    CLOSED: [2015-07-16 Thu 09:00]
    :LOGBOOK:
    - CLOSING NOTE [2015-07-16 Thu 09:00] \\
      the ast was not exported properly (and perhaps the package name of ast was
      unfitting and ast not installed.
    :END:
    
    It's weird, seems there is some inconsistencies. If I program in
    ast/ast.go , (which I currently call package go), then I can do

   func main () {
  	f :=    &NUMBER{1}
	fmt.Println(f)
	
   }
   
   inside the file ast.go. If I do that in the other package test/somename.go
   writing 

   func main () {
  	f :=    &ast.NUMBER{1}
 	fmt.Println(f)
	
   }

   then the compiler complains that he cannot figure out the arg.

   Perhaps that's because the package name etc are not yet fully clarified
   and it does not find the "ast"



   

*** DONE add to the org-path <2015-07-16 Thu 07:55>
    CLOSED: [2015-07-16 Thu 09:10]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-16 Thu 09:10]
    :END:
    ok
*** DONE make it to a worspace/package or whatever <2015-07-15 Wed 13:32>
    CLOSED: [2015-07-16 Thu 07:50]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-16 Thu 07:50]
    :END:

    See https://golang.org/doc/code.html

    it needs a workspace.

    But the workspace is just ~/go and the point where GOROOT shows

    


*** TODO can one access the stuff inside the package ast itself? <2015-07-16 Thu 10:38>

**** TODO if yes, would it help: can one make use of it? <2015-07-16 Thu 10:38>


**** DONE add print_Number <2015-07-16 Thu 14:15>
     CLOSED: [2015-07-16 Thu 14:17]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 14:17]
     :END:
**** DONE add Print_Factor <2015-07-16 Thu 14:12>
     CLOSED: [2015-07-16 Thu 14:17]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 14:17]
     :END:
**** DONE add Print_Term <2015-07-16 Thu 14:00>
     CLOSED: [2015-07-16 Thu 14:09]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 14:09]
     :END:

**** DONE add print_add_op <2015-07-16 Thu 14:00>
     CLOSED: [2015-07-16 Thu 14:32]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 14:32]
     :END:
**** DONE add Print_SimpleExpr <2015-07-16 Thu 13:36>
     CLOSED: [2015-07-16 Thu 14:00]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 14:00]
     :END:

**** FIXED Print_Term(se.T)  // error <2015-07-16 Thu 13:54>
     CLOSED: [2015-07-16 Thu 13:58]
     :LOGBOOK:
     - CLOSING NOTE [2015-07-16 Thu 13:58] \\
       ok, TERM instead of Term
     :END:

     Inside Print_SimpleExpr: bug

     perhaps duplication?
**** FIXED print_Simple_Expr leads to an compile error <2015-07-16 Thu 13:43>
     CLOSED: [2015-07-16 Thu 13:45]
     :LOGBOOK:
     - CLOSING NOTE [2015-07-16 Thu 13:45] \\
       Simply pointer type instead of struct
     :END:

**** DONE add Print_Compare_Op <2015-07-16 Thu 13:36>
     CLOSED: [2015-07-16 Thu 13:39]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 13:39]
     :END:
**** DONE add Print_Expr <2015-07-16 Thu 13:25>
     CLOSED: [2015-07-16 Thu 13:34]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 13:34]
     :END:
**** TODO make more careful name conventions <2015-07-16 Thu 14:28>
**** TODO grouping: can one group the marker methods inside the ()? <2015-07-16 Thu 14:30>
     of course it may not be worth it.
**** TODO Stmt etc.: use slices <2015-07-16 Thu 14:28>
**** DONE can one make the functions mutually recursive <2015-07-16 Thu 12:01>
     CLOSED: [2015-07-16 Thu 12:31]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 12:31]
     :END:
     yes, that seems allowed

**** DONE activate some client code <2015-07-16 Thu 12:03>
     CLOSED: [2015-07-16 Thu 14:17]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 14:17]
     :END:
**** FIXED interface receiver:  why is it not possbible to do func (Stmt) print_stmt () {..} <2015-07-16 Thu 11:25>?
     CLOSED: [2015-07-16 Thu 11:51]
     :LOGBOOK:
     - CLOSING NOTE [2015-07-16 Thu 11:51] \\
       methods don't work (the receiver cannot be abstract) but function work
     :END:
     Well, I fuess we need an argument. But that's not the only error

    Stmt: it must not be a pointer or interface type and it must be
    declared in the same package as the method. 

    so, interfaces =abstract 

***** DONE can one make a function instead of a method? <2015-07-16 Thu 11:42>
      CLOSED: [2015-07-16 Thu 11:51]
      :LOGBOOK:
      - State "DONE"       from "TODO"       [2015-07-16 Thu 11:51]
      :END:
      Ok, at least one can pass that as argument
**** TODO how did the "go" implementation walker implementation work? <2015-07-16 Thu 11:33>
      This one did not have problems.


*** TODO how does the walk-thing go <2015-07-14 Tue 07:57>

   See 

    ~/Collectionofreposes/GITHGEXTERNALS/go/src/go/ast/


    That's a kind of visitor. It imports the ast 

    It does not seem to do much, it just walks through it. As expected it's
    a recursive function. It takes two argument, the second one is the
    visitor. That's the ``functional'' argument.


*** DONE How to make an iterator over slices <2015-07-17 Fri 07:57>
    CLOSED: [2015-07-17 Fri 08:23]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-17 Fri 08:23]
    :END:
    See page 154: a read-only access: with range 

*** DONE can I make use of that function in the test thing? <2015-07-16 Thu 14:35>
    CLOSED: [2015-07-17 Fri 07:57]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-17 Fri 07:57]
    :END:
*** TODO make the print-out at least a bit readable <2015-07-16 Thu 14:34>
*** TODO make a running program making use of a program <2015-07-14 Tue 12:16>
**** DONE in the parser: how are the nodes created <2015-07-14 Tue 11:38>
     CLOSED: [2015-07-15 Wed 08:04]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-15 Wed 08:04]
     :END:
***** DONE look at standard cases <2015-07-14 Tue 11:51>
      CLOSED: [2015-07-14 Tue 12:16]
      :LOGBOOK:
      - State "DONE"       from "TODO"       [2015-07-14 Tue 12:16]
      :END:

      Here seems one:
-------------------------------------------------------------------------
	case token.SEMICOLON:
  		s = &ast.EmptyStmt{Semicolon: p.pos}
-------------------------------------------------------------------------
    ast is unclear where defined. It's a package, maybe that's what's ment-

    EmptyStmt in the package is 

	EmptyStmt struct {
		Semicolon token.Pos // position of preceding ";"
	}

	So, that's then the syntax to create a node, here 



***** DONE what does the make function do in go? <2015-07-14 Tue 11:39>
      CLOSED: [2015-07-15 Wed 08:04]
      :LOGBOOK:
      - State "DONE"       from "TODO"       [2015-07-15 Wed 08:04]
      :END:
      it's similar to new:  works for type slice, map, or chan (only). 
      It not needed here
***** CANCELLED new: can one have arguments <2015-07-14 Tue 11:45>
      CLOSED: [2015-07-15 Wed 08:04]
      :LOGBOOK:
      - CLOSING NOTE [2015-07-15 Wed 08:04]
      :END:
***** DONE why does new not have a sep. category in the ast <2015-07-14 Tue 11:46>
      CLOSED: [2015-07-14 Tue 11:47]
      :LOGBOOK:
      - State "DONE"       from "TODO"       [2015-07-14 Tue 11:47]
      :END:
      it's a built-in function, probably that's the reason
***** DORMANT if new is built in, how is it implemented <2015-07-14 Tue 11:47>
      CLOSED: [2015-07-15 Wed 08:04]
      :LOGBOOK:
      - CLOSING NOTE [2015-07-15 Wed 08:04]
      :END:
**** DONE is the ``inductive structure'' of the AST flat or not? <2015-07-14 Tue 08:51>
     CLOSED: [2015-07-15 Wed 08:05]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-15 Wed 08:05]
     :END:
     For the switch-construct it is. It needs not be, though
**** DONE what's the node.(type) there? <2015-07-14 Tue 08:08>
     CLOSED: [2015-07-14 Tue 08:35]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-14 Tue 08:35]
     :END:
     node: Node. The node is the top-``ìnterface''

     In the ast.go, there are a few comments like

	Type   Expr      // asserted type; nil means type switch X.(type)
   so probably that is a general go language thing.


   Anyway, it's a special form (or variant) of a type assertion. It's a
   type switch. It's indeed used om a big switch-case.

**** DONE how does the case switch in walk.go works <2015-07-14 Tue 08:35>
     CLOSED: [2015-07-14 Tue 11:35]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-14 Tue 11:35]
     :END:
     
     It uses a type switch switch n := node.(type). That gives various
     cases. It seems that the case-switch structure is flat , despite the
     fact that there are substructures of Node.

***** DONE flat case switch in walk.go ? <2015-07-14 Tue 09:37>
      CLOSED: [2015-07-14 Tue 11:35]
      :LOGBOOK:
      - State "DONE"       from "TODO"       [2015-07-14 Tue 11:35]
      :END:

      Is it true that the case switch is flat? -> yes

**** DONE what's the ``type'' of n in switch n := node.(type)? <2015-07-14 Tue 08:37>
     CLOSED: [2015-07-14 Tue 09:32]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-14 Tue 09:32]
     :END:
     It seems that this is _not_ fixed. It seems that n is just the node
     which is represented by n. That can be seen in walk.go by looking at
     the different cases in the case switch. Depending on the case, one
     makes use of things like n.Doc or n.Low. For instance, in case n is of
     type *Field (i.e., a reference to a Field): the type Field is a
     struct, i.e., a struct type (or record type).  Now, fields are structs
     which have a ``field'' like Doc. In a functional language, it's like

     Field of CommentGroup *  Ident *  Expr * BasicLit * CommentGoup (1)

    If of course not a tuple but a record, but ok.

     That one is a Node. Let's ignore the sub-structures, because they
     don't play a role, probably in the switching. Anyhow: the particular
     node constructed via Field has 5 args, as given above in (1). In ms, they would be matched like

     match n with
       Field(c1,i,e.b.c2) -> 

    which means the names are given locally. In the kind of programming here it's with 
    selectors like

      n.Doc 


      depending on the type switch case, different selectors apply of course.
    

     


**** TODO  what's struct ( interfaces ) <2015-07-15 Wed 08:14>
     It's in the ast of go. We shoold also look at the book and the spec
**** TODO AST: Fields why are some of the things as pointers and some not <2015-07-14 Tue 08:58>
**** DONE Constructors: it seems that in AST, they ``mimic'' those: how to set them <2015-07-14 Tue 09:16>
     CLOSED: [2015-07-15 Wed 08:06]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-15 Wed 08:06]
     :END:
     
     One may see that for instance for Field: it's a struct type, and has a
     number of fields. That seems to me like describing the result of
     applying a constructor. The question then is how to do that?

     I guess, one may simply write some functions, or better methods.

     I'd actually expect that a parser should have some such
     functions/methods, one should check there ->
     
     yes.

     It seems like CONSTRUCTOR { file : value}
***** DONE check the parser for constructors (or ast) <2015-07-14 Tue 09:21>
      CLOSED: [2015-07-15 Wed 08:06]
      :LOGBOOK:
      - State "DONE"       from "TODO"       [2015-07-15 Wed 08:06]
      :END:
*** TODO look at how the parser works <2015-07-14 Tue 07:55>
*** TODO look at the example_test.go program <2015-07-14 Tue 07:52>
*** TODO constructors / inductive definition in go <2015-07-14 Tue 07:26>
*** DONE how can one implement the AST? <2015-07-12 Sun 18:22>
    CLOSED: [2015-07-14 Tue 07:18]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-14 Tue 07:18]
    :END:
    I check via the go ast 
*** DONE what's golex go lex, why don't I have it <2015-07-12 Sun 13:59>
    CLOSED: [2015-07-12 Sun 14:23]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-12 Sun 14:23]
    :END:

    they have go tool yacc, but no lex, but there it is.

    "https://github.com/cznic/golex"

    go get lex did it! 

** Go language questions

   See also the go.org file

*** TODO how is the AST of go designed <2015-07-13 Mon 13:05>
    
    Probably they use structural subtyping. There are 4 important
    interfaces. Probably one can illustrate it as follows:

    
                   Node
                /   |    \
	    Exp    Stmt  Decl

 
The language is probably readable at

   https://golang.org/ref/spec     


For instance for the statements

Statement =
	Declaration | LabeledStmt | SimpleStmt |
	GoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt |
	FallthroughStmt | Block | IfStmt | SwitchStmt | SelectStmt | ForStmt |
	DeferStmt .

SimpleStmt = EmptyStmt | ExpressionStmt | SendStmt | IncDecStmt | Assignment | ShortVarDecl .


That does not 100% correspond to what one sees in the implementation. I
would rather like to come up with a scheme, which is more or less schematic
_AND_ corresponds 100% to the grammar. We should have a look at 2 things,
the grammar _and_ the ML ast. I guess the better starting point is the
ast. That should very much determine the tree, because it's a tree.




**** TODO why do they even distinguish 

**** TODO analyze the statements  <2015-07-13 Mon 13:55>

**** TODO where do I get the productions for Go from <2015-07-13 Mon 13:55>

**** TODO what's a production name? <2015-07-13 Mon 13:55>

**** DONE do go implement itself with yacc? <2015-07-13 Mon 13:56>
     CLOSED: [2015-07-13 Mon 14:05]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-13 Mon 14:05]
     :END:
     Nope, seems like not


     Many of them are also in the go-org, but while working here, 
     I add them here



*** Structure and meta things
**** DONE "test" package: how to make that a client to ast? <2015-07-16 Thu 08:01>
     CLOSED: [2015-07-16 Thu 12:04]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 12:04]
     :END:

     That's done now, in test/somename.go
** Yacc

 https://github.com/golang-samples/yacc/tree/master/simple

** Abysnt

*** FIXED somename.go does not compile now <2015-07-16 Thu 09:42>
    CLOSED: [2015-07-16 Thu 09:44]
    :LOGBOOK:
    - CLOSING NOTE [2015-07-16 Thu 09:44] \\
      SimpleExpr interface had a typo
    :END:
    The problemis SimpleExpr: the ``marker method'' has a typo
*** DONE finish the scheme uniformely <2015-07-16 Thu 09:14>
    CLOSED: [2015-07-16 Thu 09:27]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-16 Thu 09:27]
    :END:
    
    all stuff added


*** TODO make a sample program <2015-07-16 Thu 12:25>
*** DONE re-add the slices again and iterate over them <2015-07-16 Thu 12:21>
    CLOSED: [2015-07-17 Fri 08:24]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-17 Fri 08:24]
    :END:
*** DONE export the print statements <2015-07-16 Thu 12:17>
    CLOSED: [2015-07-16 Thu 12:18]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-16 Thu 12:18]
    :END:
*** TODO make a ``visitor'' <2015-07-16 Thu 09:54>

    There seem to be a kind of visitor pattern in the go-implementation
    itself. One question is why that is necessary at all. Because we have
    those external methods. Those seem to allow to do what a visitor can do
    (don't know about extensibility). Therefore: just implement one simple
    one.

    It seems to not be  immediately possible.    If I do that, it gives


      ./somename.go:28: cannot define new methods on non-local type ast.FACTOR




*** DONE non local methods: is that possible  <2015-07-16 Thu 10:16>
    CLOSED: [2015-07-16 Thu 10:31]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-16 Thu 10:31]
    :END:


     https://groups.google.com/forum/#!topic/golang-nuts/717yRSWjq5U

    ``The base type must not be a pointer or interface type and must be
     declared in the same package as the method.''

     Seems like not possible.


     In some discussion there is some mention of ``embedding''



    type MyExtension struct {
        otherPackage.Type
    }  


    func (me *MyExtension) NewMethod() { ... }



    Functions are easier
*** TODO can one make a visitor function across package boundaries <2015-07-16 Thu 12:05>

*** TODO external type methods: would embedding as described be a viable solution <2015-07-16 Thu 10:31>
*** TODO external type methods: compare that to the Walk-visotor in Go <2015-07-16 Thu 10:02>

*** DONE make a more complex client in somename <2015-07-16 Thu 09:14>
    CLOSED: [2015-07-16 Thu 09:54]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-16 Thu 09:54]
    :END:
*** TODO what constructs do normal people use for syntax trees <2015-07-13 Mon 12:02>
**** TODO which does go itself use <2015-07-13 Mon 12:02>
**** DONE can one check out the whole thing <2015-07-13 Mon 12:03>
     CLOSED: [2015-07-13 Mon 12:16]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-13 Mon 12:16]
     :END:

     ok, it goes with Mercury:
             hg clone https://code.google.com/p/go/

    ~/Collectionofreposes/GITHGEXTERNALS/
 
    See also now the remarks here. Also the attempts in

