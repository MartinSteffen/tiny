
* Go

  http://noypi-linux.blogspot.no/2014/07/golang-parser-generator-ebnfyacclex.html

  https://github.com/blynn/nex


  https://github.com/cznic/golex

  
** Misc (later more structure)






*** DONE add a Node to the ast.go <2015-07-17 Fri 09:12>
    CLOSED: [2015-07-17 Fri 09:18]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-17 Fri 09:18]
    :END:
*** DONE visitor: where does the Node come from <2015-07-17 Fri 09:09>
    CLOSED: [2015-07-17 Fri 09:12]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-17 Fri 09:12]
    :END:
    It's at least not in the same file, probably it's package wide
    so it's in ast.go
*** DONE make a better README.md <2015-07-16 Thu 09:54>
    CLOSED: [2015-07-17 Fri 08:24]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-17 Fri 08:24]
    :END:
     see http://stackoverflow.com/questions/8655937/github-readme-and-readme-md
*** DONE can one open a package <2015-07-16 Thu 08:11>
    CLOSED: [2015-07-17 Fri 08:25]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-17 Fri 08:25]
    :END:

    This one is not nice

	f :=    &ast.NUMBER{1}


	But it seems that it's not forseen




*** DONE capitalize the rest in ast <2015-07-16 Thu 09:03>
    CLOSED: [2015-07-16 Thu 09:09]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-16 Thu 09:09]
    :END:

*** FIXED why does the import in somename.org not work <2015-07-16 Thu 08:05>
    CLOSED: [2015-07-16 Thu 08:50]
    :LOGBOOK:
    - CLOSING NOTE [2015-07-16 Thu 08:50] \\
      some names were not exported
    :END:
    It's really weird. This one works

    import ("fmt"
	"ast")


   I would have thought it's

    import ("fmt"
	"github.com/MartinSteffen/tiny/ast")


   but those give the above errors 


   => It seems to related to the fact that some of the stuff is not

      exported

     After changing the type from number to int (which is the same but definitely
     global, I get the error

      ./somename.go:16: implicit assignment of unexported field 'n' in ast.NUMBER literal

      That means (I assume) that somehow NUMBER (or more probably it's fields)
      are not known outside


**** DONE how does one export stuff (types, and fields of constructors)  <2015-07-16 Thu 08:40>
     CLOSED: [2015-07-16 Thu 08:50]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 08:50]
     :END:

     It's done via capitalization. I changed the type and the constructor, then it works
**** DONE make it number instead of int again and export <2015-07-16 Thu 08:40>
     CLOSED: [2015-07-16 Thu 08:50]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 08:50]
     :END:
     -> Make it to "Number".
     -> make the field capitalized as wellx


**** DONE install ast.go <2015-07-16 Thu 08:24>
     CLOSED: [2015-07-16 Thu 08:38]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 08:38]
     :END:
     
     That might be the source of the problems now: the somename may not find
     it because the error is in ast.go, not in somename.go?

*** FIXED make somename.go compile: arguments for constructors  <2015-07-16 Thu 08:21>
    CLOSED: [2015-07-16 Thu 09:00]
    :LOGBOOK:
    - CLOSING NOTE [2015-07-16 Thu 09:00] \\
      the ast was not exported properly (and perhaps the package name of ast was
      unfitting and ast not installed.
    :END:
    
    It's weird, seems there is some inconsistencies. If I program in
    ast/ast.go , (which I currently call package go), then I can do

   func main () {
  	f :=    &NUMBER{1}
	fmt.Println(f)
	
   }
   
   inside the file ast.go. If I do that in the other package test/somename.go
   writing 

   func main () {
  	f :=    &ast.NUMBER{1}
 	fmt.Println(f)
	
   }

   then the compiler complains that he cannot figure out the arg.

   Perhaps that's because the package name etc are not yet fully clarified
   and it does not find the "ast"



   

*** DONE add to the org-path <2015-07-16 Thu 07:55>
    CLOSED: [2015-07-16 Thu 09:10]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-16 Thu 09:10]
    :END:
    ok
*** DONE make it to a worspace/package or whatever <2015-07-15 Wed 13:32>
    CLOSED: [2015-07-16 Thu 07:50]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-16 Thu 07:50]
    :END:

    See https://golang.org/doc/code.html

    it needs a workspace.

    But the workspace is just ~/go and the point where GOROOT shows

    


*** TODO can one access the stuff inside the package ast itself? <2015-07-16 Thu 10:38>

**** TODO if yes, would it help: can one make use of it? <2015-07-16 Thu 10:38>


**** DONE add print_Number <2015-07-16 Thu 14:15>
     CLOSED: [2015-07-16 Thu 14:17]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 14:17]
     :END:
**** DONE add Print_Factor <2015-07-16 Thu 14:12>
     CLOSED: [2015-07-16 Thu 14:17]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 14:17]
     :END:
**** DONE add Print_Term <2015-07-16 Thu 14:00>
     CLOSED: [2015-07-16 Thu 14:09]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 14:09]
     :END:

**** DONE add print_add_op <2015-07-16 Thu 14:00>
     CLOSED: [2015-07-16 Thu 14:32]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 14:32]
     :END:
**** DONE add Print_SimpleExpr <2015-07-16 Thu 13:36>
     CLOSED: [2015-07-16 Thu 14:00]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 14:00]
     :END:

**** FIXED Print_Term(se.T)  // error <2015-07-16 Thu 13:54>
     CLOSED: [2015-07-16 Thu 13:58]
     :LOGBOOK:
     - CLOSING NOTE [2015-07-16 Thu 13:58] \\
       ok, TERM instead of Term
     :END:

     Inside Print_SimpleExpr: bug

     perhaps duplication?
**** FIXED print_Simple_Expr leads to an compile error <2015-07-16 Thu 13:43>
     CLOSED: [2015-07-16 Thu 13:45]
     :LOGBOOK:
     - CLOSING NOTE [2015-07-16 Thu 13:45] \\
       Simply pointer type instead of struct
     :END:

**** DONE add Print_Compare_Op <2015-07-16 Thu 13:36>
     CLOSED: [2015-07-16 Thu 13:39]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 13:39]
     :END:
**** DONE add Print_Expr <2015-07-16 Thu 13:25>
     CLOSED: [2015-07-16 Thu 13:34]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 13:34]
     :END:
**** TODO make more careful name conventions <2015-07-16 Thu 14:28>
**** TODO grouping: can one group the marker methods inside the ()? <2015-07-16 Thu 14:30>
     of course it may not be worth it.
**** TODO Stmt etc.: use slices <2015-07-16 Thu 14:28>
**** DONE can one make the functions mutually recursive <2015-07-16 Thu 12:01>
     CLOSED: [2015-07-16 Thu 12:31]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 12:31]
     :END:
     yes, that seems allowed

**** DONE activate some client code <2015-07-16 Thu 12:03>
     CLOSED: [2015-07-16 Thu 14:17]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 14:17]
     :END:
**** FIXED interface receiver:  why is it not possbible to do func (Stmt) print_stmt () {..} <2015-07-16 Thu 11:25>?
     CLOSED: [2015-07-16 Thu 11:51]
     :LOGBOOK:
     - CLOSING NOTE [2015-07-16 Thu 11:51] \\
       methods don't work (the receiver cannot be abstract) but function work
     :END:
     Well, I fuess we need an argument. But that's not the only error

    Stmt: it must not be a pointer or interface type and it must be
    declared in the same package as the method. 

    so, interfaces =abstract 

***** DONE can one make a function instead of a method? <2015-07-16 Thu 11:42>
      CLOSED: [2015-07-16 Thu 11:51]
      :LOGBOOK:
      - State "DONE"       from "TODO"       [2015-07-16 Thu 11:51]
      :END:
      Ok, at least one can pass that as argument
**** TODO how did the "go" implementation walker implementation work? <2015-07-16 Thu 11:33>
      This one did not have problems.


*** TODO analyze the other visitor <2015-07-17 Fri 15:07>


The following seems a bit different. It also has a ``visit'' function and
an ``accept'' function. It seems that one difference is: perhaps the
ast-visitor was special isofar there was ``direct'' recursion.  But maybe
not. Anyhow

#+begin_example
 
type CarPart interface {   // CarPart not= CarPartVisitor
    Accept(CarPartVisitor) 
}

#+end_example

 


#+begin_example

type CarPartVisitor interface {
    visitWheel(wheel *Wheel)
    visitEngine(engine *Engine)
}


#+end_example


*** TODO make a visitor <2015-07-17 Fri 09:32>
**** TODO can one make a less flat visitor <2015-07-17 Fri 09:33>

     The visitor of go is flat.  My recursive function was not. So, I would
     like a similar design here.

     In my file, there's a function there Print_<nonterminal> for all of
     those. Probably, there'd b a visitor for all of those =>
     
     Let's make a visitor for all Print_X.

     That would probably mean whe need a visitor interface for all the
     phrases.


**** TODO add a visitor for staments <2015-07-17 Fri 09:59>


     What is uncear is how to escape to the other clauses. We have to see about that
     
     Why I need is an visitor, that's done with make(visitor)



**** TODO Analyze the Visitor in the go compiler <2015-07-17 Fri 13:16>

The visitor is contained in the ast-package (in the ast-directory). The
code is mainly defined in walk.go.  But it's used in a different
package. It's not clear if that is officially a visitor. One ingredient
seems missing at least if one compares it to the visitor pattern as known,
namely there is no accept method: typically, the data structure being
visited has such a method, but the ast here does not. It could however be
that one may use the word ``visitor'' more loosely, as any form of
higher-order function that allows to iterate here through an inductively
defined data structure, here the ast.

#+begin_example

type Visitor interface {
	Visit (stmt Node) (w Visitor)   
}
     
#+end_example

The Node is the catch-all type for all nodes of the ast (i.e., it is
embedded into all the more concrete nodes).


 What's strange he is also how it is later used, namely in the following
form (at the beginning of the Walk, function):


#+begin_example

func Walk(v Visitor, node Node) {
	if v = v.Visit(node); v == nil {
		return
	}

        ...

#+end_example


See also the ``client'' code. There are two things to do: define the
visitor, and then using it, by passing it to the Walk function. In order to
be a visitor, it must satisfy the Visitor interface. The only thing
required there is to implement the accept method (here Visit). So it's the
combination of both the data type plus the Visit-method that makes it to a
visitor.


#+begin_example

type visitor chan *ast.Ident   

func (v visitor) Visit(n ast.Node) (w ast.Visitor) {
	if ident, ok := n.(*ast.Ident); ok {  // ``special assignment'' for type assertion, ok is a boolean
		v <- ident  // send to channel v
	}
	return v
}


#+end_example


Note that the visitor is not even a struct, it's a channel (but I don't
know what all is allowed). But indeed, it's some reference type that
supports the Visit function. Also the receiver type, the argument type and
the return type are as requested by the Visitor interface. This
``function'' (represented by the visitor-references is of type

  Visitor .-> Node -> Visitor


The syntax of the if-statement is not too transparent. the "<-" syntax can
mean send or receive. But since on the left hand side there's a channel,
it's send.  Now, ast.Ident is just one kind of node, and n.(*ast.Ident) is
a type assertion. However, it's a ``special'' one because it's used in a
special kind of assignment. In this case, not panic occurs.


#+begin_example

func idents(f *ast.File) <-chan *ast.Ident {
	v := make(visitor)   // due to the above method, this results in a Visitor
	go func() {
		ast.Walk(v, f)    
		close(v)
	}()
	return v
}

#+end_example     


- First the interface: The "interface { ... }" is an interface type, the
  whole thing is a type declaration.  Inside the braces it the method
  specification. [It's a bit unclear why we can leave out ";" but ok]. The
  next one is the method name Accept, and  the signature    

                (stmt Stmt) (w Visitor)  

  https://golang.org/ref/spec#Signature

  This one is more stricky. The signature is of one of two forms:
  Parameters or Parameters Results. The signatures are described in
  connection with function types (there are examples). Even if not really
  explaned, the Visitor is the return type.
  

  





**** DONE why is an ``instance'' of visitor a Visitor <2015-07-17 Fri 14:10>
     CLOSED: [2015-07-17 Fri 14:20]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-17 Fri 14:20]
     :END:
     the ast.Walk function requests 2 args (it's a function not a method)

     The first argument is of type Visitor (not visitor), but we hand over
     an element of type visitor.

     Well, it ``glues'' a visitor function to it






**** TODO check some other visitor examples <2015-07-17 Fri 12:22>


     https://gist.github.com/francoishill/f0624e7760aacdc96b42

     They use more standard "terminology", what's called "Visit" here is
     called "Accept" there. It's not really an inductive structure, but
     ok. They don't deal with channels.

     CarPart is abstact, so there are no instances thereof.




***** TODO which are implementations (``substypes'') of CarPart <2015-07-17 Fri 12:53>

      We have nominal subtyping, so we need one with Accept



     

     carpart = 
     

**** TODO are the visitors the (only) way that the go books speak about higher-order programming? <2015-07-17 Fri 12:23>


**** TODO what does make <2015-07-17 Fri 11:41>
     one cannot do make (int) for instance 
     
     for slices, maps, channels

    Unlike new, make's return type is the same as the type of its argument, 

    But if make can be done for those things only, the question is what 
    is the function-visitor? I don't think it's a slice. In the example it's


**** DONE what's the type ov visitor? <2015-07-17 Fri 11:48>
     CLOSED: [2015-07-17 Fri 11:49]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-17 Fri 11:49]
     :END:
     

    ok, it's a channel

      type visitor chan *ast.Ident

      
    
    
**** DONE is there also a _use_ of the concrete visitor <2015-07-17 Fri 10:36>
     CLOSED: [2015-07-17 Fri 10:39]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-17 Fri 10:39]
     :END:
     Yes, the have

#+begin_example
func idents(f *ast.File) <-chan *ast.Ident {
	v := make(visitor)
	go func() {
		ast.Walk(v, f)
		close(v)
	}()
	return v
#+end_example


**** DONE do they have an example of a concrete visitor <2015-07-17 Fri 10:18>
     CLOSED: [2015-07-17 Fri 10:22]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-17 Fri 10:22]
     :END:
     Seems like in printer/printer_test.go there is one 
**** TODO make already now a client code <2015-07-17 Fri 10:00>
     for early testing.

**** DONE what would be the functional equivalent to a visitor, implement one <2015-07-17 Fri 09:42>
     CLOSED: [2015-07-17 Fri 09:59]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-17 Fri 09:59]
     :END:

     move to the other repos




     
**** TODO how does the walk-thing go <2015-07-14 Tue 07:57>

    That's a kind of visitor. It imports the ast 

    It does not seem to do much, it just walks through it. As expected it's
    a recursive function. It takes two argument, the second one is the
    visitor. That's the ``functional'' argument.


*** DONE How to make an iterator over slices <2015-07-17 Fri 07:57>
    CLOSED: [2015-07-17 Fri 08:23]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-17 Fri 08:23]
    :END:
    See page 154: a read-only access: with range 

*** DONE can I make use of that function in the test thing? <2015-07-16 Thu 14:35>
    CLOSED: [2015-07-17 Fri 07:57]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-17 Fri 07:57]
    :END:
*** TODO make the print-out at least a bit readable <2015-07-16 Thu 14:34>
*** TODO make a running program making use of a program <2015-07-14 Tue 12:16>
**** DONE in the parser: how are the nodes created <2015-07-14 Tue 11:38>
     CLOSED: [2015-07-15 Wed 08:04]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-15 Wed 08:04]
     :END:
***** DONE look at standard cases <2015-07-14 Tue 11:51>
      CLOSED: [2015-07-14 Tue 12:16]
      :LOGBOOK:
      - State "DONE"       from "TODO"       [2015-07-14 Tue 12:16]
      :END:

      Here seems one:
-------------------------------------------------------------------------
	case token.SEMICOLON:
  		s = &ast.EmptyStmt{Semicolon: p.pos}
-------------------------------------------------------------------------
    ast is unclear where defined. It's a package, maybe that's what's ment-

    EmptyStmt in the package is 

	EmptyStmt struct {
		Semicolon token.Pos // position of preceding ";"
	}

	So, that's then the syntax to create a node, here 



***** DONE what does the make function do in go? <2015-07-14 Tue 11:39>
      CLOSED: [2015-07-15 Wed 08:04]
      :LOGBOOK:
      - State "DONE"       from "TODO"       [2015-07-15 Wed 08:04]
      :END:
      it's similar to new:  works for type slice, map, or chan (only). 
      It not needed here
***** CANCELLED new: can one have arguments <2015-07-14 Tue 11:45>
      CLOSED: [2015-07-15 Wed 08:04]
      :LOGBOOK:
      - CLOSING NOTE [2015-07-15 Wed 08:04]
      :END:
***** DONE why does new not have a sep. category in the ast <2015-07-14 Tue 11:46>
      CLOSED: [2015-07-14 Tue 11:47]
      :LOGBOOK:
      - State "DONE"       from "TODO"       [2015-07-14 Tue 11:47]
      :END:
      it's a built-in function, probably that's the reason
***** DORMANT if new is built in, how is it implemented <2015-07-14 Tue 11:47>
      CLOSED: [2015-07-15 Wed 08:04]
      :LOGBOOK:
      - CLOSING NOTE [2015-07-15 Wed 08:04]
      :END:
**** DONE is the ``inductive structure'' of the AST flat or not? <2015-07-14 Tue 08:51>
     CLOSED: [2015-07-15 Wed 08:05]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-15 Wed 08:05]
     :END:
     For the switch-construct it is. It needs not be, though
**** DONE what's the node.(type) there? <2015-07-14 Tue 08:08>
     CLOSED: [2015-07-14 Tue 08:35]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-14 Tue 08:35]
     :END:
     node: Node. The node is the top-``Ã¬nterface''

     In the ast.go, there are a few comments like

	Type   Expr      // asserted type; nil means type switch X.(type)
   so probably that is a general go language thing.


   Anyway, it's a special form (or variant) of a type assertion. It's a
   type switch. It's indeed used om a big switch-case.

**** DONE how does the case switch in walk.go works <2015-07-14 Tue 08:35>
     CLOSED: [2015-07-14 Tue 11:35]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-14 Tue 11:35]
     :END:
     
     It uses a type switch switch n := node.(type). That gives various
     cases. It seems that the case-switch structure is flat , despite the
     fact that there are substructures of Node.

***** DONE flat case switch in walk.go ? <2015-07-14 Tue 09:37>
      CLOSED: [2015-07-14 Tue 11:35]
      :LOGBOOK:
      - State "DONE"       from "TODO"       [2015-07-14 Tue 11:35]
      :END:

      Is it true that the case switch is flat? -> yes

**** DONE what's the ``type'' of n in switch n := node.(type)? <2015-07-14 Tue 08:37>
     CLOSED: [2015-07-14 Tue 09:32]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-14 Tue 09:32]
     :END:
     It seems that this is _not_ fixed. It seems that n is just the node
     which is represented by n. That can be seen in walk.go by looking at
     the different cases in the case switch. Depending on the case, one
     makes use of things like n.Doc or n.Low. For instance, in case n is of
     type *Field (i.e., a reference to a Field): the type Field is a
     struct, i.e., a struct type (or record type).  Now, fields are structs
     which have a ``field'' like Doc. In a functional language, it's like

     Field of CommentGroup *  Ident *  Expr * BasicLit * CommentGoup (1)

    If of course not a tuple but a record, but ok.

     That one is a Node. Let's ignore the sub-structures, because they
     don't play a role, probably in the switching. Anyhow: the particular
     node constructed via Field has 5 args, as given above in (1). In ms, they would be matched like

     match n with
       Field(c1,i,e.b.c2) -> 

    which means the names are given locally. In the kind of programming here it's with 
    selectors like

      n.Doc 


      depending on the type switch case, different selectors apply of course.
    

     


**** TODO  what's struct ( interfaces ) <2015-07-15 Wed 08:14>
     It's in the ast of go. We shoold also look at the book and the spec
**** TODO AST: Fields why are some of the things as pointers and some not <2015-07-14 Tue 08:58>
**** DONE Constructors: it seems that in AST, they ``mimic'' those: how to set them <2015-07-14 Tue 09:16>
     CLOSED: [2015-07-15 Wed 08:06]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-15 Wed 08:06]
     :END:
     
     One may see that for instance for Field: it's a struct type, and has a
     number of fields. That seems to me like describing the result of
     applying a constructor. The question then is how to do that?

     I guess, one may simply write some functions, or better methods.

     I'd actually expect that a parser should have some such
     functions/methods, one should check there ->
     
     yes.

     It seems like CONSTRUCTOR { file : value}
***** DONE check the parser for constructors (or ast) <2015-07-14 Tue 09:21>
      CLOSED: [2015-07-15 Wed 08:06]
      :LOGBOOK:
      - State "DONE"       from "TODO"       [2015-07-15 Wed 08:06]
      :END:
*** TODO look at how the parser works <2015-07-14 Tue 07:55>
*** TODO look at the example_test.go program <2015-07-14 Tue 07:52>
*** TODO constructors / inductive definition in go <2015-07-14 Tue 07:26>
*** DONE how can one implement the AST? <2015-07-12 Sun 18:22>
    CLOSED: [2015-07-14 Tue 07:18]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-14 Tue 07:18]
    :END:
    I check via the go ast 
*** DONE what's golex go lex, why don't I have it <2015-07-12 Sun 13:59>
    CLOSED: [2015-07-12 Sun 14:23]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-12 Sun 14:23]
    :END:

    they have go tool yacc, but no lex, but there it is.

    "https://github.com/cznic/golex"

    go get lex did it! 

** Go language questions

   See also the go.org file

*** TODO how is the AST of go designed <2015-07-13 Mon 13:05>
    
    Probably they use structural subtyping. There are 4 important
    interfaces. Probably one can illustrate it as follows:

    
                   Node
                /   |    \
	    Exp    Stmt  Decl

 
The language is probably readable at

   https://golang.org/ref/spec     


For instance for the statements

Statement =
	Declaration | LabeledStmt | SimpleStmt |
	GoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt |
	FallthroughStmt | Block | IfStmt | SwitchStmt | SelectStmt | ForStmt |
	DeferStmt .

SimpleStmt = EmptyStmt | ExpressionStmt | SendStmt | IncDecStmt | Assignment | ShortVarDecl .


That does not 100% correspond to what one sees in the implementation. I
would rather like to come up with a scheme, which is more or less schematic
_AND_ corresponds 100% to the grammar. We should have a look at 2 things,
the grammar _and_ the ML ast. I guess the better starting point is the
ast. That should very much determine the tree, because it's a tree.




**** TODO why do they even distinguish 

**** TODO analyze the statements  <2015-07-13 Mon 13:55>

**** TODO where do I get the productions for Go from <2015-07-13 Mon 13:55>

**** TODO what's a production name? <2015-07-13 Mon 13:55>

**** DONE do go implement itself with yacc? <2015-07-13 Mon 13:56>
     CLOSED: [2015-07-13 Mon 14:05]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-13 Mon 14:05]
     :END:
     Nope, seems like not


     Many of them are also in the go-org, but while working here, 
     I add them here



*** Structure and meta things
**** DONE "test" package: how to make that a client to ast? <2015-07-16 Thu 08:01>
     CLOSED: [2015-07-16 Thu 12:04]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-16 Thu 12:04]
     :END:

     That's done now, in test/somename.go
** Yacc

 https://github.com/golang-samples/yacc/tree/master/simple

** Abysnt

*** FIXED somename.go does not compile now <2015-07-16 Thu 09:42>
    CLOSED: [2015-07-16 Thu 09:44]
    :LOGBOOK:
    - CLOSING NOTE [2015-07-16 Thu 09:44] \\
      SimpleExpr interface had a typo
    :END:
    The problemis SimpleExpr: the ``marker method'' has a typo
*** DONE finish the scheme uniformely <2015-07-16 Thu 09:14>
    CLOSED: [2015-07-16 Thu 09:27]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-16 Thu 09:27]
    :END:
    
    all stuff added


*** TODO make a sample program <2015-07-16 Thu 12:25>
*** DONE re-add the slices again and iterate over them <2015-07-16 Thu 12:21>
    CLOSED: [2015-07-17 Fri 08:24]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-17 Fri 08:24]
    :END:
*** DONE export the print statements <2015-07-16 Thu 12:17>
    CLOSED: [2015-07-16 Thu 12:18]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-16 Thu 12:18]
    :END:
*** TODO make a ``visitor'' <2015-07-16 Thu 09:54>

    There seem to be a kind of visitor pattern in the go-implementation
    itself. One question is why that is necessary at all. Because we have
    those external methods. Those seem to allow to do what a visitor can do
    (don't know about extensibility). Therefore: just implement one simple
    one.

    It seems to not be  immediately possible.    If I do that, it gives


      ./somename.go:28: cannot define new methods on non-local type ast.FACTOR




*** DONE non local methods: is that possible  <2015-07-16 Thu 10:16>
    CLOSED: [2015-07-16 Thu 10:31]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-16 Thu 10:31]
    :END:


     https://groups.google.com/forum/#!topic/golang-nuts/717yRSWjq5U

    ``The base type must not be a pointer or interface type and must be
     declared in the same package as the method.''

     Seems like not possible.


     In some discussion there is some mention of ``embedding''



    type MyExtension struct {
        otherPackage.Type
    }  


    func (me *MyExtension) NewMethod() { ... }



    Functions are easier
*** TODO can one make a visitor function across package boundaries <2015-07-16 Thu 12:05>

*** TODO external type methods: would embedding as described be a viable solution <2015-07-16 Thu 10:31>
*** TODO external type methods: compare that to the Walk-visotor in Go <2015-07-16 Thu 10:02>

*** DONE make a more complex client in somename <2015-07-16 Thu 09:14>
    CLOSED: [2015-07-16 Thu 09:54]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2015-07-16 Thu 09:54]
    :END:
*** TODO what constructs do normal people use for syntax trees <2015-07-13 Mon 12:02>
**** TODO which does go itself use <2015-07-13 Mon 12:02>
**** DONE can one check out the whole thing <2015-07-13 Mon 12:03>
     CLOSED: [2015-07-13 Mon 12:16]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2015-07-13 Mon 12:16]
     :END:

     ok, it goes with Mercury:
             hg clone https://code.google.com/p/go/

    ~/Collectionofreposes/GITHGEXTERNALS/
 
    See also now the remarks here. Also the attempts in

